{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Crossover Explorer The crossover explorer is an application that filters and displays SNPs, with the goal of looking for evidence of crossover and non-crossover events in C. elegans genomes. The top-level application runs three different scripts that implement steps in the overall workflow: a \"peak finder\" script scans a set of SNPs generated by TIGER to look for chromosomal regions that might be the result of crossover or non-crossover events another script presents a graphical user interface that lets users browse the data generated by the peak finder a visualization script creates histograms that summarize the size and location of the regions Data Files The application uses two sets of data: BSP_TIGER.marker_dataframe.pickle.gzip is a \"pickled\" and compressed Pandas data frame with the output from TIGER. Each row in the frame describes a SNP, with columns for the chromosome name, location, and the predicted parent genome (N2 or CB4856), and more. BSP_TIGER.intervals_dataframe.pickle.gzip , a summary of the SNP data, where each row defines a chromosome segment and its predicted parent. We suggest creating a new folder to use for a project directory. Move (or link) the two data files to this folder, then cd to the directory and run the crossover explorer scripts in that directory. Note for Docker users : if you are running the GUI in a Docker container you will bind mount this same directory when starting the container. Shell Commands To run one of the scripts type xo followed by one of the script names ( peaks , gui , or vis ). Each of the scripts has its own help message, which you can see by adding --help to the command. Examples This command prints the help message for the top level xo application: $ xo --help usage: xo [-h] {peaks,gui,vis,post} ... options: -h, --help show this help message and exit subcommands: operation to perform {peaks,gui,vis,post} peaks find peaks in the SNP data gui explore blocks of SNPs vis visualizations based on filtered blocks To see the help message for one of the scripts type xo , the script name, and then --help . This shell command prints the help message for the peaks script: $ xo peaks --help usage: xo peaks [-h] [--snps F] [--output F] [--max_snps N] ... Abbreviating Options The xo scripts, like most modern Unix command line applications, allow users to shorten option names, so that it is only necessary to type enough characters to distinguish one option from another. The full script name ( peaks , gui , or vis ) must be entered completely, but after that any option names can be abbreviated. Example These two commands are equivalent: $ xo peaks --output short_blocks.csv --max_snps 10 $ xo peaks --out short_blocks.csv --m 10","title":"Getting Started"},{"location":"#crossover-explorer","text":"The crossover explorer is an application that filters and displays SNPs, with the goal of looking for evidence of crossover and non-crossover events in C. elegans genomes. The top-level application runs three different scripts that implement steps in the overall workflow: a \"peak finder\" script scans a set of SNPs generated by TIGER to look for chromosomal regions that might be the result of crossover or non-crossover events another script presents a graphical user interface that lets users browse the data generated by the peak finder a visualization script creates histograms that summarize the size and location of the regions","title":"Crossover Explorer"},{"location":"#data-files","text":"The application uses two sets of data: BSP_TIGER.marker_dataframe.pickle.gzip is a \"pickled\" and compressed Pandas data frame with the output from TIGER. Each row in the frame describes a SNP, with columns for the chromosome name, location, and the predicted parent genome (N2 or CB4856), and more. BSP_TIGER.intervals_dataframe.pickle.gzip , a summary of the SNP data, where each row defines a chromosome segment and its predicted parent. We suggest creating a new folder to use for a project directory. Move (or link) the two data files to this folder, then cd to the directory and run the crossover explorer scripts in that directory. Note for Docker users : if you are running the GUI in a Docker container you will bind mount this same directory when starting the container.","title":"Data Files"},{"location":"#shell-commands","text":"To run one of the scripts type xo followed by one of the script names ( peaks , gui , or vis ). Each of the scripts has its own help message, which you can see by adding --help to the command.","title":"Shell Commands"},{"location":"#examples","text":"This command prints the help message for the top level xo application: $ xo --help usage: xo [-h] {peaks,gui,vis,post} ... options: -h, --help show this help message and exit subcommands: operation to perform {peaks,gui,vis,post} peaks find peaks in the SNP data gui explore blocks of SNPs vis visualizations based on filtered blocks To see the help message for one of the scripts type xo , the script name, and then --help . This shell command prints the help message for the peaks script: $ xo peaks --help usage: xo peaks [-h] [--snps F] [--output F] [--max_snps N] ...","title":"Examples"},{"location":"#abbreviating-options","text":"The xo scripts, like most modern Unix command line applications, allow users to shorten option names, so that it is only necessary to type enough characters to distinguish one option from another. The full script name ( peaks , gui , or vis ) must be entered completely, but after that any option names can be abbreviated.","title":"Abbreviating Options"},{"location":"#example","text":"These two commands are equivalent: $ xo peaks --output short_blocks.csv --max_snps 10 $ xo peaks --out short_blocks.csv --m 10","title":"Example"},{"location":"app/","text":"PeakViewerApp The PeakViewerApp class is the top level of the GUI. When the class is instantiated, it creates all the components (buttons, sliders, labels, etc ) and lays them out in the browser window. Layout The app is based on a Panel template named BootstrapTemplate. Applications that use this template have a title at the top of the window, a sidebar on the left side, and a main content area. In our application, we put the filter widgets in the sidebar. The main content is a \"tab\" widget with two tabs, one to show a single chromosome and the other to show summary plots. Each tab also needs its own layout: the chromosome tab has controls to navigate to different chromosomes and a column that has graphics and tables for the blocks in the current chromosome the summary tab has a text widget for entering a chromosome name pattern and a set of buttons to make plots The initialization code has a series of assignment statements that create objects and save them as instance variables, e.g. self.back_button = pn.widgets.Button(name='\u25c0\ufe0e', stylesheets=[button_style_sheet]) self.forward_button = pn.widgets.Button(name='\u25b6\ufe0e', stylesheets=[button_style_sheet]) After widgets are created they need to be placed in a layout. This statement lays out the structure of the chromosome tab: chr_tab = pn.Column( pn.pane.HTML('<h3>Chromosome</h3>'), pn.Row(self.back_button, self.chromosome_id, self.forward_button), ... ) Eventually all the layouts are saved in either the sidebar or the main section. Callbacks Another important role for the initialization function is to connect widgets to code that will be executed when the widget is activated, i.e. when the button on a scrollbar is moved, or a button is clicked. This is accomplished by telling the application to \"watch\" the value of a widget. When the value changes we want to call a function to respond to the change. This example shows how we tell the application to call a method named chromosome_edited_cb whenver the text in the chromosome name widget is updated: self.chromosome_id.param.watch(self.chromosome_edited_cb, ['value']) Initialization Method Bases: BootstrapTemplate Source code in src/xo/gui.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def __init__ ( self , ** params ): super ( PeakViewerApp , self ) . __init__ ( ** params ) self . filter = SNPFilter () self . filter_widgets = FilterBox ( self . filter ) button_style_sheet = ''':host(.solid) .bk-btn { --color: white; } ''' self . back_button = pn . widgets . Button ( name = '\u25c0\ufe0e' , stylesheets = [ button_style_sheet ]) self . forward_button = pn . widgets . Button ( name = '\u25b6\ufe0e' , stylesheets = [ button_style_sheet ]) self . chromosome_id = pn . widgets . TextInput ( name = \"\" , value = \"\" ) self . chromosome_pattern = pn . widgets . TextInput ( name = \"Chromosomes\" , value = \"BSP.*\" ) self . size_graph_button = pn . widgets . Button ( name = 'Block Size' , stylesheets = [ button_style_sheet ]) self . length_graph_button = pn . widgets . Button ( name = 'Block Length' , stylesheets = [ button_style_sheet ]) self . location_graph_button = pn . widgets . Button ( name = 'Block Location' , stylesheets = [ button_style_sheet ]) self . download_button = pn . widgets . FileDownload ( callback = self . download_cb , filename = 'summary.csv' , align = 'center' , icon = 'download' ) self . download_pane = pn . GridBox ( self . download_button , height = 200 , width = SIDEBAR_WIDTH ) self . download_button . visible = False self . attach_callbacks () chr_tab = pn . Column ( pn . pane . HTML ( '<h3>Chromosome</h3>' ), pn . Row ( self . back_button , self . chromosome_id , self . forward_button ), pn . pane . HTML ( '<p>Placeholder</p>' ), ) summ_tab = pn . Column ( pn . pane . HTML ( '<h3>Summary</h3>' ), self . chromosome_pattern , pn . Row ( self . size_graph_button , self . length_graph_button , self . location_graph_button ), pn . pane . HTML ( '<p>Click a button above to generate a plot summarizing all chromosomes.</p>' ) ) self . tabs = pn . Tabs ( ( 'Chromosome' , chr_tab ), ( 'Summary' , summ_tab ), ) self . sidebar . append ( pn . Column ( self . filter_widgets , self . download_pane , ) ) self . main . append ( self . tabs ) attach_callbacks () This method is called after all of the widgets have been created. It connects various widgets to functions that will be called when the widgets are activated. Source code in src/xo/gui.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def attach_callbacks ( self ): ''' This method is called after all of the widgets have been created. It connects various widgets to functions that will be called when the widgets are activated. ''' for w in self . filter_widgets . widgets (): w . param . watch ( self . filter_cb , [ 'value' ]) for w in [ self . back_button , self . forward_button ]: w . param . watch ( self . change_chromosome_cb , [ 'value' ]) for w in [ self . size_graph_button , self . length_graph_button , self . location_graph_button ]: w . param . watch ( self . summary_plot_cb , [ 'value' ]) self . chromosome_id . param . watch ( self . chromosome_edited_cb , [ 'value' ]) load_data ( args ) This method is called from the top level application after the GUI has been initialized. It reads the two data files needed by the application. The interval data file has the names of all the chromosomes (regardless of whether any SNPs were found); it's used to initialize the list of chromosome names. The name of the SNP data file is passed to the filter object, which manages all the SNP data. Parameters: args \u2013 command line arguments Source code in src/xo/gui.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def load_data ( self , args ): ''' This method is called from the top level application after the GUI has been initialized. It reads the two data files needed by the application. The interval data file has the names of all the chromosomes (regardless of whether any SNPs were found); it's used to initialize the list of chromosome names. The name of the SNP data file is passed to the filter object, which manages all the SNP data. Arguments: args: command line arguments ''' logging . info ( 'loading interval data' ) self . intervals = pd . read_pickle ( args . intervals , compression = 'gzip' ) . groupby ( 'chrom_id' ) self . clist = list ( self . intervals . groups . keys ()) self . cmap = { name : i for i , name in enumerate ( self . clist )} logging . info ( 'loading peak data' ) self . filter . load_data ( args . peaks ) # setting a value in the chromosome name widget triggers an update # to the graphic to display the first chromosome self . chr_index = 0 self . chromosome_id . value = self . clist [ self . chr_index ]","title":"PeakViewerApp"},{"location":"app/#peakviewerapp","text":"The PeakViewerApp class is the top level of the GUI. When the class is instantiated, it creates all the components (buttons, sliders, labels, etc ) and lays them out in the browser window. Layout The app is based on a Panel template named BootstrapTemplate. Applications that use this template have a title at the top of the window, a sidebar on the left side, and a main content area. In our application, we put the filter widgets in the sidebar. The main content is a \"tab\" widget with two tabs, one to show a single chromosome and the other to show summary plots. Each tab also needs its own layout: the chromosome tab has controls to navigate to different chromosomes and a column that has graphics and tables for the blocks in the current chromosome the summary tab has a text widget for entering a chromosome name pattern and a set of buttons to make plots The initialization code has a series of assignment statements that create objects and save them as instance variables, e.g. self.back_button = pn.widgets.Button(name='\u25c0\ufe0e', stylesheets=[button_style_sheet]) self.forward_button = pn.widgets.Button(name='\u25b6\ufe0e', stylesheets=[button_style_sheet]) After widgets are created they need to be placed in a layout. This statement lays out the structure of the chromosome tab: chr_tab = pn.Column( pn.pane.HTML('<h3>Chromosome</h3>'), pn.Row(self.back_button, self.chromosome_id, self.forward_button), ... ) Eventually all the layouts are saved in either the sidebar or the main section. Callbacks Another important role for the initialization function is to connect widgets to code that will be executed when the widget is activated, i.e. when the button on a scrollbar is moved, or a button is clicked. This is accomplished by telling the application to \"watch\" the value of a widget. When the value changes we want to call a function to respond to the change. This example shows how we tell the application to call a method named chromosome_edited_cb whenver the text in the chromosome name widget is updated: self.chromosome_id.param.watch(self.chromosome_edited_cb, ['value']) Initialization Method Bases: BootstrapTemplate Source code in src/xo/gui.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def __init__ ( self , ** params ): super ( PeakViewerApp , self ) . __init__ ( ** params ) self . filter = SNPFilter () self . filter_widgets = FilterBox ( self . filter ) button_style_sheet = ''':host(.solid) .bk-btn { --color: white; } ''' self . back_button = pn . widgets . Button ( name = '\u25c0\ufe0e' , stylesheets = [ button_style_sheet ]) self . forward_button = pn . widgets . Button ( name = '\u25b6\ufe0e' , stylesheets = [ button_style_sheet ]) self . chromosome_id = pn . widgets . TextInput ( name = \"\" , value = \"\" ) self . chromosome_pattern = pn . widgets . TextInput ( name = \"Chromosomes\" , value = \"BSP.*\" ) self . size_graph_button = pn . widgets . Button ( name = 'Block Size' , stylesheets = [ button_style_sheet ]) self . length_graph_button = pn . widgets . Button ( name = 'Block Length' , stylesheets = [ button_style_sheet ]) self . location_graph_button = pn . widgets . Button ( name = 'Block Location' , stylesheets = [ button_style_sheet ]) self . download_button = pn . widgets . FileDownload ( callback = self . download_cb , filename = 'summary.csv' , align = 'center' , icon = 'download' ) self . download_pane = pn . GridBox ( self . download_button , height = 200 , width = SIDEBAR_WIDTH ) self . download_button . visible = False self . attach_callbacks () chr_tab = pn . Column ( pn . pane . HTML ( '<h3>Chromosome</h3>' ), pn . Row ( self . back_button , self . chromosome_id , self . forward_button ), pn . pane . HTML ( '<p>Placeholder</p>' ), ) summ_tab = pn . Column ( pn . pane . HTML ( '<h3>Summary</h3>' ), self . chromosome_pattern , pn . Row ( self . size_graph_button , self . length_graph_button , self . location_graph_button ), pn . pane . HTML ( '<p>Click a button above to generate a plot summarizing all chromosomes.</p>' ) ) self . tabs = pn . Tabs ( ( 'Chromosome' , chr_tab ), ( 'Summary' , summ_tab ), ) self . sidebar . append ( pn . Column ( self . filter_widgets , self . download_pane , ) ) self . main . append ( self . tabs )","title":"PeakViewerApp"},{"location":"app/#src.xo.gui.PeakViewerApp.attach_callbacks","text":"This method is called after all of the widgets have been created. It connects various widgets to functions that will be called when the widgets are activated. Source code in src/xo/gui.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def attach_callbacks ( self ): ''' This method is called after all of the widgets have been created. It connects various widgets to functions that will be called when the widgets are activated. ''' for w in self . filter_widgets . widgets (): w . param . watch ( self . filter_cb , [ 'value' ]) for w in [ self . back_button , self . forward_button ]: w . param . watch ( self . change_chromosome_cb , [ 'value' ]) for w in [ self . size_graph_button , self . length_graph_button , self . location_graph_button ]: w . param . watch ( self . summary_plot_cb , [ 'value' ]) self . chromosome_id . param . watch ( self . chromosome_edited_cb , [ 'value' ])","title":"attach_callbacks"},{"location":"app/#src.xo.gui.PeakViewerApp.load_data","text":"This method is called from the top level application after the GUI has been initialized. It reads the two data files needed by the application. The interval data file has the names of all the chromosomes (regardless of whether any SNPs were found); it's used to initialize the list of chromosome names. The name of the SNP data file is passed to the filter object, which manages all the SNP data. Parameters: args \u2013 command line arguments Source code in src/xo/gui.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def load_data ( self , args ): ''' This method is called from the top level application after the GUI has been initialized. It reads the two data files needed by the application. The interval data file has the names of all the chromosomes (regardless of whether any SNPs were found); it's used to initialize the list of chromosome names. The name of the SNP data file is passed to the filter object, which manages all the SNP data. Arguments: args: command line arguments ''' logging . info ( 'loading interval data' ) self . intervals = pd . read_pickle ( args . intervals , compression = 'gzip' ) . groupby ( 'chrom_id' ) self . clist = list ( self . intervals . groups . keys ()) self . cmap = { name : i for i , name in enumerate ( self . clist )} logging . info ( 'loading peak data' ) self . filter . load_data ( args . peaks ) # setting a value in the chromosome name widget triggers an update # to the graphic to display the first chromosome self . chr_index = 0 self . chromosome_id . value = self . clist [ self . chr_index ]","title":"load_data"},{"location":"callbacks/","text":"Callback Functions The functions that are called when a widget is activated all have the same form: def cb(self, e): ... The first argument is always self because the callbacks in this application are all methods defined in the PeakViewerApp class. That allows them to access the data and other parts of the GUI if needed. The second argument is an event object. It has several attributes, but the one we use most often is a reference to the widget that caused the event. Here is an example. When one of the buttons next to the chromosome name in the main display is clicked we want to update the display to show the next or previous chromsome in the data set. The code that sets up the application attaches this callback to both buttons: def change_chromosome_cb(self, e): delta = 1 if e.obj is self.forward_button else -1 self.chr_index = (self.chr_index + delta) % len(self.clist) ... The goal is to update the value of the variable that holds the current chromosome ID. If the user clicked the forward button we want to add 1, otherwise we want to subtract 1. The first statement looks at e.obj , which is a reference to the widget that triggered this event, and assigns delta to be either 1 or -1, depending on which button was clicked. The second line updates the chromosome ID. filter_cb Callback function invoked when any of the widgets used for filtering (sliders, checkbox, etc) is activated. Source code in src/xo/gui.py 378 379 380 381 382 383 384 def filter_cb ( self , e ): ''' Callback function invoked when any of the widgets used for filtering (sliders, checkbox, etc) is activated. ''' e . obj . filter_cb () self . display_chromosome () change_chromosome_cb Callback function invoked when the left or right button next to the chromosome name is clicked. Source code in src/xo/gui.py 386 387 388 389 390 391 392 393 def change_chromosome_cb ( self , e ): ''' Callback function invoked when the left or right button next to the chromosome name is clicked. ''' delta = 1 if e . obj is self . forward_button else - 1 self . chr_index = ( self . chr_index + delta ) % len ( self . clist ) self . chromosome_id . value = self . clist [ self . chr_index ] chromosome_edited_cb Callback function invoked whenever the chromosome ID is updated. This will happen when the user edits the chromosome name or the name changes after a button click. Source code in src/xo/gui.py 395 396 397 398 399 400 401 402 403 404 405 def chromosome_edited_cb ( self , e ): ''' Callback function invoked whenever the chromosome ID is updated. This will happen when the user edits the chromosome name or the name changes after a button click. ''' idx = self . cmap . get ( e . obj . value ) if idx is not None : self . chr_index = idx self . chromosome_id . value = self . clist [ idx ] self . display_chromosome () toggle_text_cb Callback function invoked when a toggle button in the chromosome display is clicked. Toggles the visibility of the frame and updates the button name based on the new visibility state. Source code in src/xo/gui.py 368 369 370 371 372 373 374 375 376 def toggle_text_cb ( self , e ): ''' Callback function invoked when a toggle button in the chromosome display is clicked. Toggles the visibility of the frame and updates the button name based on the new visibility state. ''' i = e . obj . tags [ 0 ] self . block_text [ i ] . visible = not self . block_text [ i ] . visible self . block_buttons [ i ] . name = '\u2228' if self . block_text [ i ] . visible else '>' summary_plot_cb Callback function invoked when the user clicks the name of one of the histograms in the summary tab. All histograms have the same basic parameters, those that are specific to a type of data are defined in the histogram_params dictionary. Source code in src/xo/gui.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 def summary_plot_cb ( self , e ): ''' Callback function invoked when the user clicks the name of one of the histograms in the summary tab. All histograms have the same basic parameters, those that are specific to a type of data are defined in the `histogram_params` dictionary. ''' params = self . histogram_params [ e . obj . name ] self . tabs [ 1 ] . loading = True # self.filter.set_chromosome(self.chromosome_pattern.value) self . filter . chromosome = self . chromosome_pattern . value self . summary_df = self . filter . summary () fig , ax = plt . subplots ( figsize = ( 7 , 5 )) plt . hist ( self . summary_df [ params [ 'col' ]], label = self . chromosome_pattern . value , ** params [ 'hist' ]) plt . title ( params [ 'title' ]) plt . xlabel ( params [ 'xlabel' ]) plt . ylabel ( params [ 'ylabel' ]) plt . legend ( handlelength = 0 ) plt . close ( fig ) self . tabs [ 1 ] . loading = False self . tabs [ 1 ] . pop ( - 1 ) self . tabs [ 1 ] . append ( pn . pane . Matplotlib ( fig , dpi = 72 , tight = True )) self . download_button . visible = True download_cb Callback function invoked when the user clicks the download button (made visible after plotting a histogram). Source code in src/xo/gui.py 466 467 468 469 470 471 472 473 474 def download_cb ( self ): ''' Callback function invoked when the user clicks the download button (made visible after plotting a histogram). ''' sio = io . StringIO () self . summary_df . to_csv ( sio ) sio . seek ( 0 ) return sio","title":"Callback Functions"},{"location":"callbacks/#callback-functions","text":"The functions that are called when a widget is activated all have the same form: def cb(self, e): ... The first argument is always self because the callbacks in this application are all methods defined in the PeakViewerApp class. That allows them to access the data and other parts of the GUI if needed. The second argument is an event object. It has several attributes, but the one we use most often is a reference to the widget that caused the event. Here is an example. When one of the buttons next to the chromosome name in the main display is clicked we want to update the display to show the next or previous chromsome in the data set. The code that sets up the application attaches this callback to both buttons: def change_chromosome_cb(self, e): delta = 1 if e.obj is self.forward_button else -1 self.chr_index = (self.chr_index + delta) % len(self.clist) ... The goal is to update the value of the variable that holds the current chromosome ID. If the user clicked the forward button we want to add 1, otherwise we want to subtract 1. The first statement looks at e.obj , which is a reference to the widget that triggered this event, and assigns delta to be either 1 or -1, depending on which button was clicked. The second line updates the chromosome ID.","title":"Callback Functions"},{"location":"callbacks/#filter_cb","text":"Callback function invoked when any of the widgets used for filtering (sliders, checkbox, etc) is activated. Source code in src/xo/gui.py 378 379 380 381 382 383 384 def filter_cb ( self , e ): ''' Callback function invoked when any of the widgets used for filtering (sliders, checkbox, etc) is activated. ''' e . obj . filter_cb () self . display_chromosome ()","title":"filter_cb"},{"location":"callbacks/#change_chromosome_cb","text":"Callback function invoked when the left or right button next to the chromosome name is clicked. Source code in src/xo/gui.py 386 387 388 389 390 391 392 393 def change_chromosome_cb ( self , e ): ''' Callback function invoked when the left or right button next to the chromosome name is clicked. ''' delta = 1 if e . obj is self . forward_button else - 1 self . chr_index = ( self . chr_index + delta ) % len ( self . clist ) self . chromosome_id . value = self . clist [ self . chr_index ]","title":"change_chromosome_cb"},{"location":"callbacks/#chromosome_edited_cb","text":"Callback function invoked whenever the chromosome ID is updated. This will happen when the user edits the chromosome name or the name changes after a button click. Source code in src/xo/gui.py 395 396 397 398 399 400 401 402 403 404 405 def chromosome_edited_cb ( self , e ): ''' Callback function invoked whenever the chromosome ID is updated. This will happen when the user edits the chromosome name or the name changes after a button click. ''' idx = self . cmap . get ( e . obj . value ) if idx is not None : self . chr_index = idx self . chromosome_id . value = self . clist [ idx ] self . display_chromosome ()","title":"chromosome_edited_cb"},{"location":"callbacks/#toggle_text_cb","text":"Callback function invoked when a toggle button in the chromosome display is clicked. Toggles the visibility of the frame and updates the button name based on the new visibility state. Source code in src/xo/gui.py 368 369 370 371 372 373 374 375 376 def toggle_text_cb ( self , e ): ''' Callback function invoked when a toggle button in the chromosome display is clicked. Toggles the visibility of the frame and updates the button name based on the new visibility state. ''' i = e . obj . tags [ 0 ] self . block_text [ i ] . visible = not self . block_text [ i ] . visible self . block_buttons [ i ] . name = '\u2228' if self . block_text [ i ] . visible else '>'","title":"toggle_text_cb"},{"location":"callbacks/#summary_plot_cb","text":"Callback function invoked when the user clicks the name of one of the histograms in the summary tab. All histograms have the same basic parameters, those that are specific to a type of data are defined in the histogram_params dictionary. Source code in src/xo/gui.py 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 def summary_plot_cb ( self , e ): ''' Callback function invoked when the user clicks the name of one of the histograms in the summary tab. All histograms have the same basic parameters, those that are specific to a type of data are defined in the `histogram_params` dictionary. ''' params = self . histogram_params [ e . obj . name ] self . tabs [ 1 ] . loading = True # self.filter.set_chromosome(self.chromosome_pattern.value) self . filter . chromosome = self . chromosome_pattern . value self . summary_df = self . filter . summary () fig , ax = plt . subplots ( figsize = ( 7 , 5 )) plt . hist ( self . summary_df [ params [ 'col' ]], label = self . chromosome_pattern . value , ** params [ 'hist' ]) plt . title ( params [ 'title' ]) plt . xlabel ( params [ 'xlabel' ]) plt . ylabel ( params [ 'ylabel' ]) plt . legend ( handlelength = 0 ) plt . close ( fig ) self . tabs [ 1 ] . loading = False self . tabs [ 1 ] . pop ( - 1 ) self . tabs [ 1 ] . append ( pn . pane . Matplotlib ( fig , dpi = 72 , tight = True )) self . download_button . visible = True","title":"summary_plot_cb"},{"location":"callbacks/#download_cb","text":"Callback function invoked when the user clicks the download button (made visible after plotting a histogram). Source code in src/xo/gui.py 466 467 468 469 470 471 472 473 474 def download_cb ( self ): ''' Callback function invoked when the user clicks the download button (made visible after plotting a histogram). ''' sio = io . StringIO () self . summary_df . to_csv ( sio ) sio . seek ( 0 ) return sio","title":"download_cb"},{"location":"chromosomes/","text":"Chromosome Display The function that displays a chromosome is a method named display_chromosome , defined in the PeakViewerApp class. The method is called whenver the user clicks the left or right button next to the chromosome name or edits the chromosome name. To break the code into manageable pieces there are two \"helper methods\": _make_patches builds a list of rectangles for the \"ribbon\" display _make_grid builds the column of blocks, interleaving graphical representations of the SNPs with a text view of the dataframe display_chromosome Update the chromosome display. Called whenever the chromosome ID changes. Shows a set of rectangular patches where the color is based on the region identified by the HMM. Below that is a grid with one row for each block of SNPs identifed by the peak finder. Source code in src/xo/gui.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def display_chromosome ( self ): ''' Update the chromosome display. Called whenever the chromosome ID changes. Shows a set of rectangular patches where the color is based on the region identified by the HMM. Below that is a grid with one row for each block of SNPs identifed by the peak finder. ''' chr_id = self . chromosome_id . value chrom = self . intervals . get_group ( chr_id ) rects = PatchCollection ( self . _make_patches ( chrom ), match_original = True ) fig , ax = plt . subplots ( figsize = ( 12 , 1 )) plt . box ( False ) plt . yticks ([]) plt . xticks ( ticks = np . linspace ( 0 , 20000000 , 5 ), labels = [ f ' { int ( n * 20 ) } Mbp' for n in np . linspace ( 0 , 1 , 5 )]) ax . xaxis . set_ticks_position ( 'top' ) ax . add_collection ( rects ) plt . xlim ( 0 , 20000000 ) plt . ylim ( 0 , 2000000 ) plt . close ( fig ) graphic = pn . Column ( pn . pane . Matplotlib ( fig , dpi = 72 , tight = True )) if self . filter . has_chromosome_block ( chr_id ): self . blocks , self . summary = self . filter . apply ( chr_id ) # self._make_dots() grid = self . _make_grid () graphic . append ( grid ) self . tabs [ 0 ] . pop ( - 1 ) self . tabs [ 0 ] . append ( graphic ) _make_patches Create a horizontal bar as a collection of rectangular patches, with one patch for each row in the data frame. The rows have the starting coordinates lengths, and HMM states of chromosome regions, used to define the width and color of a patch. Source code in src/xo/gui.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def _make_patches ( self , df ): ''' Create a horizontal bar as a collection of rectangular patches, with one patch for each row in the data frame. The rows have the starting coordinates lengths, and HMM states of chromosome regions, used to define the width and color of a patch. ''' pcolor = { 'CB4856' : 'dodgerblue' , 'N2' : 'indianred' } res = [] for _ , r in df . iterrows (): c = pcolor . get ( r . hmm_state ) or 'lightgray' res . append ( Rectangle (( r . start , 500000 ), r . length , 1000000 , color = c )) res . append ( Circle (( r . start , 750000 ), 50000 , color = 'black' )) return res _make_grid Make a Column object that has a collection of figures, one for each block in a chromosome (saved in an instance var). The figures are saved in a grid. Below each figure is a text widget containing the data frame with the filtered SNPs in the block, i.e. the grid for a chromosome with N blocks as 2*N rows. The frames are initially hidden. The rows that have figures also have a toggle button; clicking this button will show or hide the frame. Source code in src/xo/gui.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def _make_grid ( self ): ''' Make a Column object that has a collection of figures, one for each block in a chromosome (saved in an instance var). The figures are saved in a grid. Below each figure is a text widget containing the data frame with the filtered SNPs in the block, i.e. the grid for a chromosome with N blocks as 2*N rows. The frames are initially hidden. The rows that have figures also have a toggle button; clicking this button will show or hide the frame. ''' pcolor = { 'CB4856' : 'dodgerblue' , 'N2' : 'indianred' , 'uCB4856' : 'lightsteelblue' , 'uN2' : 'lightpink' , 'unknown' : 'lightgray' , 'het' : 'palegoldenrod' , } self . block_buttons = {} self . block_text = {} g = pn . Column () for blk_id , blk_stats in self . summary . iterrows (): block = self . blocks . get_group ( blk_id ) fig , ax = plt . subplots ( figsize = ( 10 , 0.8 )) plt . box ( False ) plt . xlim ( 0 , 10 ) plt . ylim ( 0 , 0.8 ) plt . yticks ([]) x0 = block . iloc [ 0 ] . position size = int ( blk_stats . blk_size ) length = int ( blk_stats . blk_len ) w = block . iloc [ - 1 ] . position - x0 plt . xticks ( ticks = np . linspace ( 0 , 10 , 5 ), labels = [ f ' { int ( n * w ) } bp' for n in np . linspace ( 0 , 1 , 5 )]) plt . suptitle ( f 'Block # { blk_id } \\n Start: { ( x0 / 1000000 ) : .1f } Mbp \\n Size: { size } SNPs \\n Length: { length } bp' , x = 0 , y = 0.75 , size = 'medium' , ha = 'left' ) res = [] for _ , snp in block . iterrows (): p = (( snp . position - x0 ) / length ) if length > 0 else 0 x = p * 10 res . append ( Circle (( x , 0.2 ), 0.1 , color = pcolor [ snp . base_geno ])) dots = PatchCollection ( res , match_original = True ) ax . add_collection ( dots ) plt . close ( fig ) self . block_buttons [ blk_id ] = pn . widgets . Button ( name = '>' , align = 'center' , tags = [ blk_id ]) self . block_buttons [ blk_id ] . on_click ( self . toggle_text_cb ) df = block [[ 'position' , 'base_geno' , 'hmm_state1' , 'reference' , 'ref_reads' , 'variant' , 'var_reads' ]] self . block_text [ blk_id ] = pn . pane . DataFrame ( df , visible = False ) g . append ( pn . Row ( self . block_buttons [ blk_id ], pn . pane . Matplotlib ( fig , dpi = 72 , tight = True ), styles = { 'background' : 'WhiteSmoke' }, )) g . append ( pn . Row ( self . block_text [ blk_id ])) return g","title":"Chromosome Display"},{"location":"chromosomes/#chromosome-display","text":"The function that displays a chromosome is a method named display_chromosome , defined in the PeakViewerApp class. The method is called whenver the user clicks the left or right button next to the chromosome name or edits the chromosome name. To break the code into manageable pieces there are two \"helper methods\": _make_patches builds a list of rectangles for the \"ribbon\" display _make_grid builds the column of blocks, interleaving graphical representations of the SNPs with a text view of the dataframe","title":"Chromosome Display"},{"location":"chromosomes/#display_chromosome","text":"Update the chromosome display. Called whenever the chromosome ID changes. Shows a set of rectangular patches where the color is based on the region identified by the HMM. Below that is a grid with one row for each block of SNPs identifed by the peak finder. Source code in src/xo/gui.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def display_chromosome ( self ): ''' Update the chromosome display. Called whenever the chromosome ID changes. Shows a set of rectangular patches where the color is based on the region identified by the HMM. Below that is a grid with one row for each block of SNPs identifed by the peak finder. ''' chr_id = self . chromosome_id . value chrom = self . intervals . get_group ( chr_id ) rects = PatchCollection ( self . _make_patches ( chrom ), match_original = True ) fig , ax = plt . subplots ( figsize = ( 12 , 1 )) plt . box ( False ) plt . yticks ([]) plt . xticks ( ticks = np . linspace ( 0 , 20000000 , 5 ), labels = [ f ' { int ( n * 20 ) } Mbp' for n in np . linspace ( 0 , 1 , 5 )]) ax . xaxis . set_ticks_position ( 'top' ) ax . add_collection ( rects ) plt . xlim ( 0 , 20000000 ) plt . ylim ( 0 , 2000000 ) plt . close ( fig ) graphic = pn . Column ( pn . pane . Matplotlib ( fig , dpi = 72 , tight = True )) if self . filter . has_chromosome_block ( chr_id ): self . blocks , self . summary = self . filter . apply ( chr_id ) # self._make_dots() grid = self . _make_grid () graphic . append ( grid ) self . tabs [ 0 ] . pop ( - 1 ) self . tabs [ 0 ] . append ( graphic )","title":"display_chromosome"},{"location":"chromosomes/#_make_patches","text":"Create a horizontal bar as a collection of rectangular patches, with one patch for each row in the data frame. The rows have the starting coordinates lengths, and HMM states of chromosome regions, used to define the width and color of a patch. Source code in src/xo/gui.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def _make_patches ( self , df ): ''' Create a horizontal bar as a collection of rectangular patches, with one patch for each row in the data frame. The rows have the starting coordinates lengths, and HMM states of chromosome regions, used to define the width and color of a patch. ''' pcolor = { 'CB4856' : 'dodgerblue' , 'N2' : 'indianred' } res = [] for _ , r in df . iterrows (): c = pcolor . get ( r . hmm_state ) or 'lightgray' res . append ( Rectangle (( r . start , 500000 ), r . length , 1000000 , color = c )) res . append ( Circle (( r . start , 750000 ), 50000 , color = 'black' )) return res","title":"_make_patches"},{"location":"chromosomes/#_make_grid","text":"Make a Column object that has a collection of figures, one for each block in a chromosome (saved in an instance var). The figures are saved in a grid. Below each figure is a text widget containing the data frame with the filtered SNPs in the block, i.e. the grid for a chromosome with N blocks as 2*N rows. The frames are initially hidden. The rows that have figures also have a toggle button; clicking this button will show or hide the frame. Source code in src/xo/gui.py 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def _make_grid ( self ): ''' Make a Column object that has a collection of figures, one for each block in a chromosome (saved in an instance var). The figures are saved in a grid. Below each figure is a text widget containing the data frame with the filtered SNPs in the block, i.e. the grid for a chromosome with N blocks as 2*N rows. The frames are initially hidden. The rows that have figures also have a toggle button; clicking this button will show or hide the frame. ''' pcolor = { 'CB4856' : 'dodgerblue' , 'N2' : 'indianred' , 'uCB4856' : 'lightsteelblue' , 'uN2' : 'lightpink' , 'unknown' : 'lightgray' , 'het' : 'palegoldenrod' , } self . block_buttons = {} self . block_text = {} g = pn . Column () for blk_id , blk_stats in self . summary . iterrows (): block = self . blocks . get_group ( blk_id ) fig , ax = plt . subplots ( figsize = ( 10 , 0.8 )) plt . box ( False ) plt . xlim ( 0 , 10 ) plt . ylim ( 0 , 0.8 ) plt . yticks ([]) x0 = block . iloc [ 0 ] . position size = int ( blk_stats . blk_size ) length = int ( blk_stats . blk_len ) w = block . iloc [ - 1 ] . position - x0 plt . xticks ( ticks = np . linspace ( 0 , 10 , 5 ), labels = [ f ' { int ( n * w ) } bp' for n in np . linspace ( 0 , 1 , 5 )]) plt . suptitle ( f 'Block # { blk_id } \\n Start: { ( x0 / 1000000 ) : .1f } Mbp \\n Size: { size } SNPs \\n Length: { length } bp' , x = 0 , y = 0.75 , size = 'medium' , ha = 'left' ) res = [] for _ , snp in block . iterrows (): p = (( snp . position - x0 ) / length ) if length > 0 else 0 x = p * 10 res . append ( Circle (( x , 0.2 ), 0.1 , color = pcolor [ snp . base_geno ])) dots = PatchCollection ( res , match_original = True ) ax . add_collection ( dots ) plt . close ( fig ) self . block_buttons [ blk_id ] = pn . widgets . Button ( name = '>' , align = 'center' , tags = [ blk_id ]) self . block_buttons [ blk_id ] . on_click ( self . toggle_text_cb ) df = block [[ 'position' , 'base_geno' , 'hmm_state1' , 'reference' , 'ref_reads' , 'variant' , 'var_reads' ]] self . block_text [ blk_id ] = pn . pane . DataFrame ( df , visible = False ) g . append ( pn . Row ( self . block_buttons [ blk_id ], pn . pane . Matplotlib ( fig , dpi = 72 , tight = True ), styles = { 'background' : 'WhiteSmoke' }, )) g . append ( pn . Row ( self . block_text [ blk_id ])) return g","title":"_make_grid"},{"location":"filterbox/","text":"Filter Widgets Five new classes are defined the beginning of gui.py . Four of them are used to define the widgets that control filter parameters: BlockSizeFilterWidget is an integer range slider to specify minimum and maximum block sizes BlockLengthFilterWidget is another integer range slider, for block lengths CoverageFilterWidget is a single-value integer slider SupportFilterWidget is a checkbox that is either on or off The initialization methods for each widget defines the widget's name (which will be displayed above the widget when it is shown in the GUI) and sets its initial values. Initialization methods are also passed a reference to a SNPFilter object that has the code that will do the actual filtering before a chromosome is displayed. When a filter widget is updated ( e.g. when the user moves a slider) a \"callback function\" is activated. The function will record the new setting in the SNPFilter so it is used the next time the filter is called. The fifth class, called FilterBox, is a type of widget called a \"layout\". It provides a way to collect all the filter widgets in a single location and provides a common interface to all the filters. FilterBox Bases: Column A FilterBox is a column layout that has a label and an instance of each of the filter widgets. in the order they will be displayed. Parameters: f \u2013 the filter object with the method that does the filtering (passed to the constructors for each filter widget) Source code in src/xo/gui.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def __init__ ( self , f ): ''' The `__init__` method instantiates the widgets that will filter SNPs and puts them in the Column in the order they will be displayed. Arguments: f: the filter object with the method that does the filtering (passed to the constructors for each filter widget) ''' super ( FilterBox , self ) . __init__ () self . _widgets = [ BlockSizeFilterWidget ( f ), BlockLengthFilterWidget ( f ), CoverageFilterWidget ( f ), SupportFilterWidget ( f ), ] self . append ( pn . pane . HTML ( \"<h3>Filters</h3>\" )) self . extend ( self . _widgets ) widgets () Return a list of filter widgets. Source code in src/xo/gui.py 165 166 167 168 169 def widgets ( self ): ''' Return a list of filter widgets. ''' return self . _widgets BlockSizeFilterWidget Bases: IntRangeSlider Use an integer range slider to provide settings for the filter based on the count of the number of SNPs in a block. Source code in src/xo/gui.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , f ): ''' Arguments: f: the SNPFilter object that will do the filtering. ''' super ( BlockSizeFilterWidget , self ) . __init__ ( name = 'Block Size (#SNPs)' , start = 0 , end = 100 , ) self . value = ( self . start , self . end ) self . tags = [ 'size' , 1 ] self . filter = f filter_cb () Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 49 50 51 52 53 54 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . size_range = self . value BlockLengthFilterWidget Bases: IntRangeSlider Use an integer range slider to provide settings for the filter based on length of a block, defined as the number of bases between the first and last SNP. Source code in src/xo/gui.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , f ): ''' Arguments: f: the SNPFilter object that will do the filtering. ''' super ( BlockLengthFilterWidget , self ) . __init__ ( name = 'Block Length (bp)' , start = 0 , end = 10000 , step = 10 , ) self . value = ( self . start , self . end ) self . tags = [ 'length' , 1 ] self . filter = f filter_cb () Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 79 80 81 82 83 84 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . length_range = self . value CoverageFilterWidget Bases: IntSlider Use an integer slider to display the coverage cutoff value. Source code in src/xo/gui.py 92 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , f ): ''' Arguments: f: the filter object with the method that does the filtering ''' super ( CoverageFilterWidget , self ) . __init__ ( name = 'Minimum Coverage' , start = 0 , end = 10 , ) self . value = self . start self . tags = [ 'coverage' , 0 ] self . filter = f filter_cb () Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 106 107 108 109 110 111 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . coverage = self . value SupportFilterWidget Bases: Checkbox Use a checkbox to tell the filter to keep SNPs if the base genome column matches the HMM state column. Source code in src/xo/gui.py 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , f ): ''' Arguments: f: the filter object with the method that does the filtering ''' super ( SupportFilterWidget , self ) . __init__ ( name = 'Genome Match' , ) self . tags = [ 'match' , 0 ] self . filter = f filter_cb () Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 131 132 133 134 135 136 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . matched = self . value","title":"Filter Widgets"},{"location":"filterbox/#filter-widgets","text":"Five new classes are defined the beginning of gui.py . Four of them are used to define the widgets that control filter parameters: BlockSizeFilterWidget is an integer range slider to specify minimum and maximum block sizes BlockLengthFilterWidget is another integer range slider, for block lengths CoverageFilterWidget is a single-value integer slider SupportFilterWidget is a checkbox that is either on or off The initialization methods for each widget defines the widget's name (which will be displayed above the widget when it is shown in the GUI) and sets its initial values. Initialization methods are also passed a reference to a SNPFilter object that has the code that will do the actual filtering before a chromosome is displayed. When a filter widget is updated ( e.g. when the user moves a slider) a \"callback function\" is activated. The function will record the new setting in the SNPFilter so it is used the next time the filter is called. The fifth class, called FilterBox, is a type of widget called a \"layout\". It provides a way to collect all the filter widgets in a single location and provides a common interface to all the filters.","title":"Filter Widgets"},{"location":"filterbox/#filterbox","text":"Bases: Column A FilterBox is a column layout that has a label and an instance of each of the filter widgets. in the order they will be displayed. Parameters: f \u2013 the filter object with the method that does the filtering (passed to the constructors for each filter widget) Source code in src/xo/gui.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def __init__ ( self , f ): ''' The `__init__` method instantiates the widgets that will filter SNPs and puts them in the Column in the order they will be displayed. Arguments: f: the filter object with the method that does the filtering (passed to the constructors for each filter widget) ''' super ( FilterBox , self ) . __init__ () self . _widgets = [ BlockSizeFilterWidget ( f ), BlockLengthFilterWidget ( f ), CoverageFilterWidget ( f ), SupportFilterWidget ( f ), ] self . append ( pn . pane . HTML ( \"<h3>Filters</h3>\" )) self . extend ( self . _widgets )","title":"FilterBox"},{"location":"filterbox/#src.xo.gui.FilterBox.widgets","text":"Return a list of filter widgets. Source code in src/xo/gui.py 165 166 167 168 169 def widgets ( self ): ''' Return a list of filter widgets. ''' return self . _widgets","title":"widgets"},{"location":"filterbox/#blocksizefilterwidget","text":"Bases: IntRangeSlider Use an integer range slider to provide settings for the filter based on the count of the number of SNPs in a block. Source code in src/xo/gui.py 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , f ): ''' Arguments: f: the SNPFilter object that will do the filtering. ''' super ( BlockSizeFilterWidget , self ) . __init__ ( name = 'Block Size (#SNPs)' , start = 0 , end = 100 , ) self . value = ( self . start , self . end ) self . tags = [ 'size' , 1 ] self . filter = f","title":"BlockSizeFilterWidget"},{"location":"filterbox/#src.xo.gui.BlockSizeFilterWidget.filter_cb","text":"Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 49 50 51 52 53 54 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . size_range = self . value","title":"filter_cb"},{"location":"filterbox/#blocklengthfilterwidget","text":"Bases: IntRangeSlider Use an integer range slider to provide settings for the filter based on length of a block, defined as the number of bases between the first and last SNP. Source code in src/xo/gui.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def __init__ ( self , f ): ''' Arguments: f: the SNPFilter object that will do the filtering. ''' super ( BlockLengthFilterWidget , self ) . __init__ ( name = 'Block Length (bp)' , start = 0 , end = 10000 , step = 10 , ) self . value = ( self . start , self . end ) self . tags = [ 'length' , 1 ] self . filter = f","title":"BlockLengthFilterWidget"},{"location":"filterbox/#src.xo.gui.BlockLengthFilterWidget.filter_cb","text":"Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 79 80 81 82 83 84 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . length_range = self . value","title":"filter_cb"},{"location":"filterbox/#coveragefilterwidget","text":"Bases: IntSlider Use an integer slider to display the coverage cutoff value. Source code in src/xo/gui.py 92 93 94 95 96 97 98 99 100 101 102 103 104 def __init__ ( self , f ): ''' Arguments: f: the filter object with the method that does the filtering ''' super ( CoverageFilterWidget , self ) . __init__ ( name = 'Minimum Coverage' , start = 0 , end = 10 , ) self . value = self . start self . tags = [ 'coverage' , 0 ] self . filter = f","title":"CoverageFilterWidget"},{"location":"filterbox/#src.xo.gui.CoverageFilterWidget.filter_cb","text":"Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 106 107 108 109 110 111 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . coverage = self . value","title":"filter_cb"},{"location":"filterbox/#supportfilterwidget","text":"Bases: Checkbox Use a checkbox to tell the filter to keep SNPs if the base genome column matches the HMM state column. Source code in src/xo/gui.py 120 121 122 123 124 125 126 127 128 129 def __init__ ( self , f ): ''' Arguments: f: the filter object with the method that does the filtering ''' super ( SupportFilterWidget , self ) . __init__ ( name = 'Genome Match' , ) self . tags = [ 'match' , 0 ] self . filter = f","title":"SupportFilterWidget"},{"location":"filterbox/#src.xo.gui.SupportFilterWidget.filter_cb","text":"Callback activated when the slider changes. Saves the new slider settings in the filter object. Source code in src/xo/gui.py 131 132 133 134 135 136 def filter_cb ( self ): ''' Callback activated when the slider changes. Saves the new slider settings in the filter object. ''' self . filter . matched = self . value","title":"filter_cb"},{"location":"filters/","text":"Filters The filter module defines a class named SNPFilter. An app creates an instance of this class to act as an interface to the full set of SNPs. The general workflow is: call the method that loads SNP data from a CSV file assign values for filtering criteria (block size, etc ) call the apply method to apply the filters SNPFilter () A SNPFilter object is the main interface to the SNP data. After creating the object call the load_data method to read a data frame with SNP calls produced by TIGER. Set filtering parameters (block length, etc ), then call the filter method to apply all the filters. Attributes: snps \u2013 the input data frame chromosome \u2013 when filtering return SNPs in chromosomes with names that match this pattern size_range \u2013 a pair of integers with the minimum and maximum number of SNPs in a block length_range \u2013 a pair of integers with the minimum and maxium block length (in base pairs) coverage \u2013 a minimum number of reads required to use a SNP matched \u2013 True if a SNP's base genome must be the same as the HMM state Source code in src/xo/filters.py 40 41 42 43 44 45 46 47 48 49 def __init__ ( self ): self . _snps = None self . _chromosome = 'BSP.*' self . _min_size = 1 self . _max_size = 100 self . _min_length = 1 self . _max_length = 10000 self . _coverage = 0 self . _matched = False self . _groups = None chromosome property writable Filtered SNPs must have names that match this pattern. size_range property writable Minimum and maximum block size (number of SNPs) length_range property writable Minimum and maximum block length (bp) matched property writable If True SNPs must have matching HMM state coverage property writable Minimum number of reads for a SNP load_data ( fn ) Read the SNP data from a CSV file. Add two new columns (chromosome length and relative SNP location) used in summaries. SNPs are grouped by chromosome ID and the groups are saved in an instance variable. Parameters: fn \u2013 name of CSV file Source code in src/xo/filters.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def load_data ( self , fn ): ''' Read the SNP data from a CSV file. Add two new columns (chromosome length and relative SNP location) used in summaries. SNPs are grouped by chromosome ID and the groups are saved in an instance variable. Arguments: fn: name of CSV file ''' self . _snps = pd . read_csv ( fn ) . rename ( columns = { 'Unnamed: 0' : 'SNP' }) self . _snps [ 'chr_length' ] = self . _snps . chromosome . map ( lambda n : chr_length [ n ]) self . _snps [ 'location' ] = self . _snps . position / self . _snps . chr_length self . _groups = self . _snps . groupby ( 'chrom_id' ) has_chromosome_block ( chr_id ) Return True if the SNP data has blocks for a chromosome. Parameters: chr_id \u2013 the name of the chromosome to look for. Source code in src/xo/filters.py 65 66 67 68 69 70 71 72 def has_chromosome_block ( self , chr_id ): ''' Return True if the SNP data has blocks for a chromosome. Arguments: chr_id: the name of the chromosome to look for. ''' return chr_id in self . _groups . groups apply ( chr_id = None ) Apply the match and coverage criteria to a single chromosome, return the filtered SNPs grouped by blocks and a summary table. If a chromosome ID is passed apply the filters to that chromosome only, otherwise use the complete set of all SNPs. The first step is to make a subset of SNPs that pass the coverage and match filters. The resulting frame is then grouped by block. The second step makes a separate summary frame based on size and location of each block. This frame is then filtered using the block size and block length filters. Parameters: chr_id \u2013 the ID of the chromosome to use Returns: groups \u2013 the blocks in the filtered chromosome summary \u2013 a data frame with size, length, and location of each block Source code in src/xo/filters.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def apply ( self , chr_id = None ): ''' Apply the match and coverage criteria to a single chromosome, return the filtered SNPs grouped by blocks and a summary table. If a chromosome ID is passed apply the filters to that chromosome only, otherwise use the complete set of all SNPs. The first step is to make a subset of SNPs that pass the coverage and match filters. The resulting frame is then grouped by block. The second step makes a separate summary frame based on size and location of each block. This frame is then filtered using the block size and block length filters. Arguments: chr_id: the ID of the chromosome to use Returns: groups: the blocks in the filtered chromosome summary: a data frame with size, length, and location of each block ''' if chr_id is None : df = self . _snps [ self . _snps . chrom_id . map ( lambda s : bool ( re . match ( self . _chromosome , s )))] else : df = self . _groups . get_group ( chr_id ) logging . info ( f 'Filtering { len ( df ) } SNPs' ) if self . _matched : df = df [ df . base_geno == df . hmm_state1 ] logging . info ( f ' { len ( df ) } match' ) if self . _coverage : df = df [ df . var_reads + df . ref_reads > self . _coverage ] logging . info ( f ' { len ( df ) } have coverage > { self . _coverage } ' ) if chr_id is None : groups = df . groupby ([ 'chrom_id' , 'blk_id' ]) else : groups = df . groupby ( 'blk_id' ) logging . info ( f ' { len ( groups ) } groups' ) sf = pd . concat ( [ groups . size () . rename ( 'blk_size' ), ( groups . max ( 'position' ) - groups . min ( 'position' )) . position . rename ( 'blk_len' ), groups . mean ( 'location' ) . location . rename ( 'blk_loc' ), ], axis = 1 ) min_size = sf . blk_size >= self . _min_size max_size = sf . blk_size <= self . _max_size min_len = sf . blk_len >= self . _min_length max_len = sf . blk_len <= self . _max_length sf = sf [ min_size & max_size & min_len & max_len ] logging . info ( f 'summary has { sf . blk_size . sum () } SNPs in { len ( sf ) } blocks' ) return groups , sf","title":"filters"},{"location":"filters/#filters","text":"The filter module defines a class named SNPFilter. An app creates an instance of this class to act as an interface to the full set of SNPs. The general workflow is: call the method that loads SNP data from a CSV file assign values for filtering criteria (block size, etc ) call the apply method to apply the filters","title":"Filters"},{"location":"filters/#src.xo.filters.SNPFilter","text":"A SNPFilter object is the main interface to the SNP data. After creating the object call the load_data method to read a data frame with SNP calls produced by TIGER. Set filtering parameters (block length, etc ), then call the filter method to apply all the filters. Attributes: snps \u2013 the input data frame chromosome \u2013 when filtering return SNPs in chromosomes with names that match this pattern size_range \u2013 a pair of integers with the minimum and maximum number of SNPs in a block length_range \u2013 a pair of integers with the minimum and maxium block length (in base pairs) coverage \u2013 a minimum number of reads required to use a SNP matched \u2013 True if a SNP's base genome must be the same as the HMM state Source code in src/xo/filters.py 40 41 42 43 44 45 46 47 48 49 def __init__ ( self ): self . _snps = None self . _chromosome = 'BSP.*' self . _min_size = 1 self . _max_size = 100 self . _min_length = 1 self . _max_length = 10000 self . _coverage = 0 self . _matched = False self . _groups = None","title":"SNPFilter"},{"location":"filters/#src.xo.filters.SNPFilter.chromosome","text":"Filtered SNPs must have names that match this pattern.","title":"chromosome"},{"location":"filters/#src.xo.filters.SNPFilter.size_range","text":"Minimum and maximum block size (number of SNPs)","title":"size_range"},{"location":"filters/#src.xo.filters.SNPFilter.length_range","text":"Minimum and maximum block length (bp)","title":"length_range"},{"location":"filters/#src.xo.filters.SNPFilter.matched","text":"If True SNPs must have matching HMM state","title":"matched"},{"location":"filters/#src.xo.filters.SNPFilter.coverage","text":"Minimum number of reads for a SNP","title":"coverage"},{"location":"filters/#src.xo.filters.SNPFilter.load_data","text":"Read the SNP data from a CSV file. Add two new columns (chromosome length and relative SNP location) used in summaries. SNPs are grouped by chromosome ID and the groups are saved in an instance variable. Parameters: fn \u2013 name of CSV file Source code in src/xo/filters.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def load_data ( self , fn ): ''' Read the SNP data from a CSV file. Add two new columns (chromosome length and relative SNP location) used in summaries. SNPs are grouped by chromosome ID and the groups are saved in an instance variable. Arguments: fn: name of CSV file ''' self . _snps = pd . read_csv ( fn ) . rename ( columns = { 'Unnamed: 0' : 'SNP' }) self . _snps [ 'chr_length' ] = self . _snps . chromosome . map ( lambda n : chr_length [ n ]) self . _snps [ 'location' ] = self . _snps . position / self . _snps . chr_length self . _groups = self . _snps . groupby ( 'chrom_id' )","title":"load_data"},{"location":"filters/#src.xo.filters.SNPFilter.has_chromosome_block","text":"Return True if the SNP data has blocks for a chromosome. Parameters: chr_id \u2013 the name of the chromosome to look for. Source code in src/xo/filters.py 65 66 67 68 69 70 71 72 def has_chromosome_block ( self , chr_id ): ''' Return True if the SNP data has blocks for a chromosome. Arguments: chr_id: the name of the chromosome to look for. ''' return chr_id in self . _groups . groups","title":"has_chromosome_block"},{"location":"filters/#src.xo.filters.SNPFilter.apply","text":"Apply the match and coverage criteria to a single chromosome, return the filtered SNPs grouped by blocks and a summary table. If a chromosome ID is passed apply the filters to that chromosome only, otherwise use the complete set of all SNPs. The first step is to make a subset of SNPs that pass the coverage and match filters. The resulting frame is then grouped by block. The second step makes a separate summary frame based on size and location of each block. This frame is then filtered using the block size and block length filters. Parameters: chr_id \u2013 the ID of the chromosome to use Returns: groups \u2013 the blocks in the filtered chromosome summary \u2013 a data frame with size, length, and location of each block Source code in src/xo/filters.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def apply ( self , chr_id = None ): ''' Apply the match and coverage criteria to a single chromosome, return the filtered SNPs grouped by blocks and a summary table. If a chromosome ID is passed apply the filters to that chromosome only, otherwise use the complete set of all SNPs. The first step is to make a subset of SNPs that pass the coverage and match filters. The resulting frame is then grouped by block. The second step makes a separate summary frame based on size and location of each block. This frame is then filtered using the block size and block length filters. Arguments: chr_id: the ID of the chromosome to use Returns: groups: the blocks in the filtered chromosome summary: a data frame with size, length, and location of each block ''' if chr_id is None : df = self . _snps [ self . _snps . chrom_id . map ( lambda s : bool ( re . match ( self . _chromosome , s )))] else : df = self . _groups . get_group ( chr_id ) logging . info ( f 'Filtering { len ( df ) } SNPs' ) if self . _matched : df = df [ df . base_geno == df . hmm_state1 ] logging . info ( f ' { len ( df ) } match' ) if self . _coverage : df = df [ df . var_reads + df . ref_reads > self . _coverage ] logging . info ( f ' { len ( df ) } have coverage > { self . _coverage } ' ) if chr_id is None : groups = df . groupby ([ 'chrom_id' , 'blk_id' ]) else : groups = df . groupby ( 'blk_id' ) logging . info ( f ' { len ( groups ) } groups' ) sf = pd . concat ( [ groups . size () . rename ( 'blk_size' ), ( groups . max ( 'position' ) - groups . min ( 'position' )) . position . rename ( 'blk_len' ), groups . mean ( 'location' ) . location . rename ( 'blk_loc' ), ], axis = 1 ) min_size = sf . blk_size >= self . _min_size max_size = sf . blk_size <= self . _max_size min_len = sf . blk_len >= self . _min_length max_len = sf . blk_len <= self . _max_length sf = sf [ min_size & max_size & min_len & max_len ] logging . info ( f 'summary has { sf . blk_size . sum () } SNPs in { len ( sf ) } blocks' ) return groups , sf","title":"apply"},{"location":"gui/","text":"View SNPs in the GUI The GUI allows users to explore the blocks generated by the peaks command. The window has two parts, as shown by this screenshot: The left side of the screen displays a set of filters which allow you to set limits on sizes and other attributes of blocks. The right side of the window is for graphical displays. Note there are two tabs at the top of this part of the window. The chromosome tab , shown above, displays one chromosome at a time. Clicking the summary tab will change to show plots that summarize all the blocks in the data set. Opening the GUI From the command line run the xo script with the gui command: $ xo gui The GUI is based on a Python library named Panel. It's similar to Jupyter in that it creates a server on your local system, and you use the GUI by opening a web browser and connecting to the server. The default port number is 5006, but you can specify a different port with the --port option if you need to ( e.g. if you have a different web app already using that port). The GUI needs two data files. The first is the CSV file with block descriptions created by the xo peaks command. The default file name is peaks.csv , but you can specify a different name using the --peaks option. The other data file used by the GUI is a summary of locations of blocks of SNPs. The default file name is BSP_TIGER.intervals_dataframe.pickle.gzip , but a different name can be specified using --intervals . Chromosome Display At the top of the chromosome tab you will see a box containing a chromosome name with two buttons on either side. Below that is a \"ribbon\" that classifies regions of the chromosome as having come from the CB4856 parent (in blue) or the N2 parent (in red). The black dots represent the locations of blocks of SNPs identified by the peak finder. The controls allow you to switch to a different chromosome. Click the triangle shaped buttons next to the chromosome name to move to the previous or next chromosome in the data set. If you want to go directly do a different chromosome click on the chromosome name and edit the name there. If the name is valid the display will be updated when you hit the enter key or click somewhere outside the text box. Note: If a chromosome has a lot of blocks there will be a delay before the screen is updated while the app makes all the graphics for the lower part of the display. Below the \"ribbon\" you will see the blocks identified by the peak finder for the current chromosome. This screenshot shows the first three blocks for chromosome BSP-OR-001-4: The circles in each row correspond to the SNPs in that block. The scale below the circles indicates the relative position of each SNP, and the text to the left has an overview of the block. In this example, the first row of circles is for a block that starts 2Mbp into the chromosome. The block has 19 SNPs, spread out over a region 421bp long (the distance between the first and last SNP in the block). The colors of the circles are based on how the HMM in TIGER classified the SNPs. Bright blue and red are where the HMM is confident a SNP is from CB4856 or N2, respectively. Paler blue and red are for SNPs with lower confidence. Gray and yellow are for undetermined or ambiguous SNPs. To the left of each row of circles is a button with a \"reveal\" icon (looks like a greater-than symbol). If you click this button the GUI will show a table based on the data frame for the block, showing all the details of each SNP. Here is the display for block #1 in the example: Note how there are 13 rows, one for each SNP, and that each row corresponds to a circle in the graphic. Most of the circles are gray (\"unknown\") but one is bright red, having been identified as an N2 SNP. Clicking the button again will hide the block. Filters There are four ways to control which SNPs are displayed in the blocks: a block size filter limits the display to contain only blocks that have a number of SNPs between a lower and upper limit a block length filter shows only blocks that have an overall length -- the distance, in base pairs, between the first and last SNP in the block -- within a specified lower and upper limit the minimum coverage filter selects SNPs that are supported by reads (the values in the ref_reads and var_reads columns in the SNP table); a SNP is included in the display if the sum of the numbers in these two columns is greater then a specified limit the genome match filter is either on or off; when it's on, a SNP is included only if the state inferred by the HMM (shown in the hmm_state1 column in the table) matches the base in the chromosome (indicated by the base_geno column). Widgets Each filter has its own \"widget\" on the left side of the GUI that is used to set values for that filter: Block Size Widget Click on the control on the left side of the slider and drag it to set the minimum block size, or click and drag the control on the right to set the maximum block size. As you drag a control the display will update to show the new value. The value won't take effect until you let go of the button. Block Length Widget This widget is another double-sided slider, used the same way as the block size widget, but this one controls the block length. Minimum Coverage Widget This slider has only one button, used to specify the coverage value. You can either drag the button or click anywhere along the length of the slider. Genome Match Widget This widget is a simple check-box. Click inside the box to turn the filter on or off. How Filters are Applied The chromosome display will be updated immediately, as soon you update a widget. All four filters are applied each time the display is updated. Each time the chromosome display is updated -- either by adjusting one of the widgets, or by selecting a new chromosome -- all the filters are applied and the resulting SNPs are used to generate the display. Only those blocks that are within the bounds of the block size and block length filters are shown. Inside the blocks that pass those filters only SNPs that pass the coverage and match filters are shown. Summary Plots The other tab in the graphics panel is named Summary . Click on the tab name to display a set of controls for generating plots based on summarizing filtered blocks across all chromosomes: Chromosome Names The default setting will generate plots using all of the chromosomes. However, if you want to make separate plots for different groups, you can enter a name pattern using regular expression syntax in the text box labeled \"Chromosomes\". The initial value in this box is BSP.* , meaning \"any chromosome with a name that starts with BSP\" (in other words, all chromosomes). Some other examples of name patterns: pattern chromosomes used BSP-OR.* all oocytes BSP-SR.* all spermatocytes BSP-OR-10.* the 10 worms with names BSP-OR-001, BSP-OR-002, ... BSP-OR-009. BSP-SR-.*-1 chromosome 1 for all spermatocytes Buttons The three summary plots are all histograms. Click the button for the summary you want, based on block size, block length, or block location (relative location on the chromosome). Note that the histograms will be based on filtered data. The application first selects the chromosomes that have names that match the pattern in the \"Chromosomes\" box. It then applies all the filters, using the current settings in the filter widgets. The result blocks are then used to generate the histograms. When the graph has been generated (it may take a few seconds) it will be displayed in the GUI: Exiting the GUI Close the web browser window. If you started the GUI by typing xo gui on the command line you can stop it by clicking in the terminal window and typing \u2303C (control-C).","title":"View SNPs in the GUI"},{"location":"gui/#view-snps-in-the-gui","text":"The GUI allows users to explore the blocks generated by the peaks command. The window has two parts, as shown by this screenshot: The left side of the screen displays a set of filters which allow you to set limits on sizes and other attributes of blocks. The right side of the window is for graphical displays. Note there are two tabs at the top of this part of the window. The chromosome tab , shown above, displays one chromosome at a time. Clicking the summary tab will change to show plots that summarize all the blocks in the data set.","title":"View SNPs in the GUI"},{"location":"gui/#opening-the-gui","text":"From the command line run the xo script with the gui command: $ xo gui The GUI is based on a Python library named Panel. It's similar to Jupyter in that it creates a server on your local system, and you use the GUI by opening a web browser and connecting to the server. The default port number is 5006, but you can specify a different port with the --port option if you need to ( e.g. if you have a different web app already using that port). The GUI needs two data files. The first is the CSV file with block descriptions created by the xo peaks command. The default file name is peaks.csv , but you can specify a different name using the --peaks option. The other data file used by the GUI is a summary of locations of blocks of SNPs. The default file name is BSP_TIGER.intervals_dataframe.pickle.gzip , but a different name can be specified using --intervals .","title":"Opening the GUI"},{"location":"gui/#chromosome-display","text":"At the top of the chromosome tab you will see a box containing a chromosome name with two buttons on either side. Below that is a \"ribbon\" that classifies regions of the chromosome as having come from the CB4856 parent (in blue) or the N2 parent (in red). The black dots represent the locations of blocks of SNPs identified by the peak finder. The controls allow you to switch to a different chromosome. Click the triangle shaped buttons next to the chromosome name to move to the previous or next chromosome in the data set. If you want to go directly do a different chromosome click on the chromosome name and edit the name there. If the name is valid the display will be updated when you hit the enter key or click somewhere outside the text box. Note: If a chromosome has a lot of blocks there will be a delay before the screen is updated while the app makes all the graphics for the lower part of the display. Below the \"ribbon\" you will see the blocks identified by the peak finder for the current chromosome. This screenshot shows the first three blocks for chromosome BSP-OR-001-4: The circles in each row correspond to the SNPs in that block. The scale below the circles indicates the relative position of each SNP, and the text to the left has an overview of the block. In this example, the first row of circles is for a block that starts 2Mbp into the chromosome. The block has 19 SNPs, spread out over a region 421bp long (the distance between the first and last SNP in the block). The colors of the circles are based on how the HMM in TIGER classified the SNPs. Bright blue and red are where the HMM is confident a SNP is from CB4856 or N2, respectively. Paler blue and red are for SNPs with lower confidence. Gray and yellow are for undetermined or ambiguous SNPs. To the left of each row of circles is a button with a \"reveal\" icon (looks like a greater-than symbol). If you click this button the GUI will show a table based on the data frame for the block, showing all the details of each SNP. Here is the display for block #1 in the example: Note how there are 13 rows, one for each SNP, and that each row corresponds to a circle in the graphic. Most of the circles are gray (\"unknown\") but one is bright red, having been identified as an N2 SNP. Clicking the button again will hide the block.","title":"Chromosome Display"},{"location":"gui/#filters","text":"There are four ways to control which SNPs are displayed in the blocks: a block size filter limits the display to contain only blocks that have a number of SNPs between a lower and upper limit a block length filter shows only blocks that have an overall length -- the distance, in base pairs, between the first and last SNP in the block -- within a specified lower and upper limit the minimum coverage filter selects SNPs that are supported by reads (the values in the ref_reads and var_reads columns in the SNP table); a SNP is included in the display if the sum of the numbers in these two columns is greater then a specified limit the genome match filter is either on or off; when it's on, a SNP is included only if the state inferred by the HMM (shown in the hmm_state1 column in the table) matches the base in the chromosome (indicated by the base_geno column).","title":"Filters"},{"location":"gui/#widgets","text":"Each filter has its own \"widget\" on the left side of the GUI that is used to set values for that filter:","title":"Widgets"},{"location":"gui/#block-size-widget","text":"Click on the control on the left side of the slider and drag it to set the minimum block size, or click and drag the control on the right to set the maximum block size. As you drag a control the display will update to show the new value. The value won't take effect until you let go of the button.","title":"Block Size Widget"},{"location":"gui/#block-length-widget","text":"This widget is another double-sided slider, used the same way as the block size widget, but this one controls the block length.","title":"Block Length Widget"},{"location":"gui/#minimum-coverage-widget","text":"This slider has only one button, used to specify the coverage value. You can either drag the button or click anywhere along the length of the slider.","title":"Minimum Coverage Widget"},{"location":"gui/#genome-match-widget","text":"This widget is a simple check-box. Click inside the box to turn the filter on or off.","title":"Genome Match Widget"},{"location":"gui/#how-filters-are-applied","text":"The chromosome display will be updated immediately, as soon you update a widget. All four filters are applied each time the display is updated. Each time the chromosome display is updated -- either by adjusting one of the widgets, or by selecting a new chromosome -- all the filters are applied and the resulting SNPs are used to generate the display. Only those blocks that are within the bounds of the block size and block length filters are shown. Inside the blocks that pass those filters only SNPs that pass the coverage and match filters are shown.","title":"How Filters are Applied"},{"location":"gui/#summary-plots","text":"The other tab in the graphics panel is named Summary . Click on the tab name to display a set of controls for generating plots based on summarizing filtered blocks across all chromosomes:","title":"Summary Plots"},{"location":"gui/#chromosome-names","text":"The default setting will generate plots using all of the chromosomes. However, if you want to make separate plots for different groups, you can enter a name pattern using regular expression syntax in the text box labeled \"Chromosomes\". The initial value in this box is BSP.* , meaning \"any chromosome with a name that starts with BSP\" (in other words, all chromosomes). Some other examples of name patterns: pattern chromosomes used BSP-OR.* all oocytes BSP-SR.* all spermatocytes BSP-OR-10.* the 10 worms with names BSP-OR-001, BSP-OR-002, ... BSP-OR-009. BSP-SR-.*-1 chromosome 1 for all spermatocytes","title":"Chromosome Names"},{"location":"gui/#buttons","text":"The three summary plots are all histograms. Click the button for the summary you want, based on block size, block length, or block location (relative location on the chromosome). Note that the histograms will be based on filtered data. The application first selects the chromosomes that have names that match the pattern in the \"Chromosomes\" box. It then applies all the filters, using the current settings in the filter widgets. The result blocks are then used to generate the histograms. When the graph has been generated (it may take a few seconds) it will be displayed in the GUI:","title":"Buttons"},{"location":"gui/#exiting-the-gui","text":"Close the web browser window. If you started the GUI by typing xo gui on the command line you can stop it by clicking in the terminal window and typing \u2303C (control-C).","title":"Exiting the GUI"},{"location":"gui_module/","text":"gui.py All of the code for the crossover explorer GUI is in a single Python file named gui.py . The main sections of this file are: definitions of the \"filter widgets\" (sliders and checkboxes for setting filtering options) a class named PeakViewerApp that defines the Panel app and lays out the widgets; the class also defines methods that display a chromosome and handle events by invoking \"callback\" functions code that creates and launches the viewer","title":"gui"},{"location":"gui_module/#guipy","text":"All of the code for the crossover explorer GUI is in a single Python file named gui.py . The main sections of this file are: definitions of the \"filter widgets\" (sliders and checkboxes for setting filtering options) a class named PeakViewerApp that defines the Panel app and lays out the widgets; the class also defines methods that display a chromosome and handle events by invoking \"callback\" functions code that creates and launches the viewer","title":"gui.py"},{"location":"main/","text":"Main Program The top level application ( xo.py ) uses the argparse library to parse command line arguments and then call the function that implemements the command specified on the command line. init_cli The default file names for the SNPs file, intervals file, and peaks file are defined in the init_cli function. First see if there is an environment variable for a file name (there will be when the program is run in a Docker container), otherwise use the predefined default. The argument parser sets up a \"subparser\" for each command (peaks, gui, or vis). The subparsers define the options valid for that command and specify which function to call if the command is found on the command line. These functions are all imported from other modules. Source Use argparse to create the command line API. Returns: \u2013 a Namespace object with values of the command line arguments. Source code in src/xo/xo.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def init_cli (): \"\"\" Use argparse to create the command line API. Returns: a Namespace object with values of the command line arguments. \"\"\" snps_default = os . environ . get ( 'XO_SNPS' ) or 'BSP_TIGER.marker_dataframe.pickle.gzip' intervals_default = os . environ . get ( 'XO_INTERVALS' ) or 'BSP_TIGER.intervals_dataframe.pickle.gzip' peaks_default = os . environ . get ( 'XO_PEAKS' ) or 'peaks.csv' save_default = os . environ . get ( 'XO_SAVE' ) or 'summary.csv' parser = argparse . ArgumentParser () subparsers = parser . add_subparsers ( title = 'subcommands' , description = 'operation to perform' ) peak_parser = subparsers . add_parser ( 'peaks' , help = 'find peaks in the SNP data' ) peak_parser . add_argument ( '--snps' , metavar = 'F' , default = snps_default , help = 'input (IGER marker) file' ) peak_parser . add_argument ( '--output' , metavar = 'F' , default = peaks_default , help = 'output file' ) peak_parser . add_argument ( '--max_snps' , metavar = 'N' , type = int , default = 1000 , help = \"max number of SNPs in a block\" ) peak_parser . set_defaults ( func = peak_finder ) gui_parser = subparsers . add_parser ( 'gui' , help = 'explore blocks of SNPs' ) gui_parser . add_argument ( '--intervals' , metavar = 'F' , default = intervals_default , help = 'SNP summaries' ) gui_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) gui_parser . add_argument ( '--port' , metavar = 'N' , type = int , default = 5006 , help = 'local port for the Panel server' ) gui_parser . set_defaults ( func = start_app ) vis_parser = subparsers . add_parser ( 'vis' , help = 'visualizations based on filtered blocks' ) vis_parser . add_argument ( 'command' , metavar = 'P' , choices = plot_commands , help = f 'type of plot to make { plot_commands } ' ) vis_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) vis_parser . add_argument ( '--chromosomes' , metavar = 'P' , default = 'BSP.*' , help = 'chromosome name pattern' ) vis_parser . add_argument ( '--size' , metavar = 'N' , nargs = 2 , type = int , default = ( 0 , 100 ), help = 'block size range (#SNPs)' ) vis_parser . add_argument ( '--length' , metavar = 'N' , nargs = 2 , type = int , default = ( 0 , 10000 ), help = 'block length range (bp)' ) vis_parser . add_argument ( '--coverage' , metavar = 'N' , type = int , help = 'minimum coverage' ) vis_parser . add_argument ( '--match' , action = 'store_true' , help = 'require genome match' ) vis_parser . add_argument ( '--save' , metavar = 'F' , default = save_default , help = 'write summary dataframe to this file' ) vis_parser . set_defaults ( func = visualize ) post_parser = subparsers . add_parser ( 'post' , help = 'postprocessing of filtered blocks' ) post_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) post_parser . set_defaults ( func = post ) if len ( sys . argv ) == 1 : parser . print_help () exit () return parser . parse_args () main The argument parser associates a function with each script name, all we need to do here is call that function. Source code in src/xo/xo.py 94 95 96 97 98 99 100 101 def main (): \"\"\" The argument parser associates a function with each script name, all we need to do here is call that function. \"\"\" args = init_cli () setup_logging ( args ) args . func ( args )","title":"xo"},{"location":"main/#main-program","text":"The top level application ( xo.py ) uses the argparse library to parse command line arguments and then call the function that implemements the command specified on the command line.","title":"Main Program"},{"location":"main/#init_cli","text":"The default file names for the SNPs file, intervals file, and peaks file are defined in the init_cli function. First see if there is an environment variable for a file name (there will be when the program is run in a Docker container), otherwise use the predefined default. The argument parser sets up a \"subparser\" for each command (peaks, gui, or vis). The subparsers define the options valid for that command and specify which function to call if the command is found on the command line. These functions are all imported from other modules. Source Use argparse to create the command line API. Returns: \u2013 a Namespace object with values of the command line arguments. Source code in src/xo/xo.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def init_cli (): \"\"\" Use argparse to create the command line API. Returns: a Namespace object with values of the command line arguments. \"\"\" snps_default = os . environ . get ( 'XO_SNPS' ) or 'BSP_TIGER.marker_dataframe.pickle.gzip' intervals_default = os . environ . get ( 'XO_INTERVALS' ) or 'BSP_TIGER.intervals_dataframe.pickle.gzip' peaks_default = os . environ . get ( 'XO_PEAKS' ) or 'peaks.csv' save_default = os . environ . get ( 'XO_SAVE' ) or 'summary.csv' parser = argparse . ArgumentParser () subparsers = parser . add_subparsers ( title = 'subcommands' , description = 'operation to perform' ) peak_parser = subparsers . add_parser ( 'peaks' , help = 'find peaks in the SNP data' ) peak_parser . add_argument ( '--snps' , metavar = 'F' , default = snps_default , help = 'input (IGER marker) file' ) peak_parser . add_argument ( '--output' , metavar = 'F' , default = peaks_default , help = 'output file' ) peak_parser . add_argument ( '--max_snps' , metavar = 'N' , type = int , default = 1000 , help = \"max number of SNPs in a block\" ) peak_parser . set_defaults ( func = peak_finder ) gui_parser = subparsers . add_parser ( 'gui' , help = 'explore blocks of SNPs' ) gui_parser . add_argument ( '--intervals' , metavar = 'F' , default = intervals_default , help = 'SNP summaries' ) gui_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) gui_parser . add_argument ( '--port' , metavar = 'N' , type = int , default = 5006 , help = 'local port for the Panel server' ) gui_parser . set_defaults ( func = start_app ) vis_parser = subparsers . add_parser ( 'vis' , help = 'visualizations based on filtered blocks' ) vis_parser . add_argument ( 'command' , metavar = 'P' , choices = plot_commands , help = f 'type of plot to make { plot_commands } ' ) vis_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) vis_parser . add_argument ( '--chromosomes' , metavar = 'P' , default = 'BSP.*' , help = 'chromosome name pattern' ) vis_parser . add_argument ( '--size' , metavar = 'N' , nargs = 2 , type = int , default = ( 0 , 100 ), help = 'block size range (#SNPs)' ) vis_parser . add_argument ( '--length' , metavar = 'N' , nargs = 2 , type = int , default = ( 0 , 10000 ), help = 'block length range (bp)' ) vis_parser . add_argument ( '--coverage' , metavar = 'N' , type = int , help = 'minimum coverage' ) vis_parser . add_argument ( '--match' , action = 'store_true' , help = 'require genome match' ) vis_parser . add_argument ( '--save' , metavar = 'F' , default = save_default , help = 'write summary dataframe to this file' ) vis_parser . set_defaults ( func = visualize ) post_parser = subparsers . add_parser ( 'post' , help = 'postprocessing of filtered blocks' ) post_parser . add_argument ( '--peaks' , metavar = 'F' , default = peaks_default , help = 'blocks saved by peaks.py' ) post_parser . set_defaults ( func = post ) if len ( sys . argv ) == 1 : parser . print_help () exit () return parser . parse_args ()","title":"init_cli"},{"location":"main/#main","text":"The argument parser associates a function with each script name, all we need to do here is call that function. Source code in src/xo/xo.py 94 95 96 97 98 99 100 101 def main (): \"\"\" The argument parser associates a function with each script name, all we need to do here is call that function. \"\"\" args = init_cli () setup_logging ( args ) args . func ( args )","title":"main"},{"location":"modules/","text":"Source Directory The source code is in a folder named src . Inside that folder is another folder named xo , which is a Python module (since it has an __init__.py file). src \u2514\u2500\u2500 xo \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 filters.py \u251c\u2500\u2500 gui.py \u251c\u2500\u2500 peaks.py \u251c\u2500\u2500 vis.py \u2514\u2500\u2500 xo.py The top level program is in xo.py . The code for the three commands -- peaks , gui , and vis -- are in files with the same name as the command. The file named filters.py has the definition of a SNPFilter class that is used by the GUI and the vis script.","title":"Source Directory"},{"location":"modules/#source-directory","text":"The source code is in a folder named src . Inside that folder is another folder named xo , which is a Python module (since it has an __init__.py file). src \u2514\u2500\u2500 xo \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 filters.py \u251c\u2500\u2500 gui.py \u251c\u2500\u2500 peaks.py \u251c\u2500\u2500 vis.py \u2514\u2500\u2500 xo.py The top level program is in xo.py . The code for the three commands -- peaks , gui , and vis -- are in files with the same name as the command. The file named filters.py has the definition of a SNPFilter class that is used by the GUI and the vis script.","title":"Source Directory"},{"location":"peaks/","text":"Peak Finder This script scans a chromosome to look for sequences of SNPs that are potentially associated with crossover or non-crossover events. Searching for Blocks of SNPs The name \"peak finder\" comes from the method we use to look for these events. We define a signal function that is based on counting the number of SNPs. At any location in the chromosome, let f be the total number of CB4856 SNPs seen up to that point, and let g be the total number of N2 SNPs seen to that point. Then our signal function is simply f \u2212 g . As we move across the chromosome, the signal goes up whenever we encounter a CB4856 SNP and goes down whenever we see an N2 SNP. As an example, suppose a chromosome has a single crossover point: before the location of the point all the SNPs are from the CB4856 parent, and after this location all the SNPs are from the N2 parent. The signal will increase monotonically up to location of the point and then decrease monotonically. The signal has one peak, at the location where the crossover occurred. Non-Crossovers If there are non-crossover events, we expect to see small regions where SNPs from one parent occur somewhere in the middle of a long sequence from the other parent. These will appear as small \"blips\" in the signal: a short drop in the region that is otherwise increasing, or a short rise in the region that is otherwise decreasing. We use the find_peaks function from the NumPy signal processing library to look for these regions in our signal function. We define a block to be the set of SNPs from the start to the end of one of the regions identified by the peak finder. Look for Valleys as Well as Peaks Some chromosomes will have N2 SNPs before the main crossover point and CB4856 SNPs after that. In this case the signal decreases before the crossover and increases after that point, so the crossover is at a location where there is a \"valley\" and not a peak. The NumPy function returns locations of both peaks and valleys, and our code saves locations from each type of \"blip\". Maximum Block Size If a chromosome has a single crossover, the peak finding algorithm will think the sequence from the start of the chromosome up to the crossover location is a block, and the sequence from the crossover point to the end of the chromosome is another block. To prevent these two blocks from being included in the output the script has a block size limit, which is the maximum number of SNPs that can be included in a block. There are also \"pathological\" cases where there are small blips inside a longer region that also stands out from the background. In these situations the peak finder reports the coordinates of the longer enclosing block along with the locations of the smaller blocks nested inside. Choosing a smaller block size limit will prevent the enclosing block from being included in the output while still including the smaller blocks. No Crossovers Some chromosomes in the data set have no crossover points. In these situations the peak finder will not find a peak or a valley and the output file will have no blocks for this chromosome. Shell Command To run the peak finder with the default options type $ xo peaks That will read the SNP data from TIGER and write blocks to an output file in CSV format. The default input file name is BSP_TIGER.marker_dataframe.pickle.gzip . A different file name can be specified with the --snps option. The default output file name is peaks.csv . A different name can be specified with --output . The default block size limit is 1000 SNPs. A different value can be specified with the --max_snps option. Output File The data written by this command is saved in a CSV file. Each row in the file is a SNP that occurs in a block identified by the peak finder. The lines are exact copies of the lines from the original input file, including the original SNP ID in the first column. One new column has been appended to each line. This column is a block ID number, which allows the GUI and visualization commands to group SNPs by blocks.","title":"Peak Finder"},{"location":"peaks/#peak-finder","text":"This script scans a chromosome to look for sequences of SNPs that are potentially associated with crossover or non-crossover events.","title":"Peak Finder"},{"location":"peaks/#searching-for-blocks-of-snps","text":"The name \"peak finder\" comes from the method we use to look for these events. We define a signal function that is based on counting the number of SNPs. At any location in the chromosome, let f be the total number of CB4856 SNPs seen up to that point, and let g be the total number of N2 SNPs seen to that point. Then our signal function is simply f \u2212 g . As we move across the chromosome, the signal goes up whenever we encounter a CB4856 SNP and goes down whenever we see an N2 SNP. As an example, suppose a chromosome has a single crossover point: before the location of the point all the SNPs are from the CB4856 parent, and after this location all the SNPs are from the N2 parent. The signal will increase monotonically up to location of the point and then decrease monotonically. The signal has one peak, at the location where the crossover occurred.","title":"Searching for Blocks of SNPs"},{"location":"peaks/#non-crossovers","text":"If there are non-crossover events, we expect to see small regions where SNPs from one parent occur somewhere in the middle of a long sequence from the other parent. These will appear as small \"blips\" in the signal: a short drop in the region that is otherwise increasing, or a short rise in the region that is otherwise decreasing. We use the find_peaks function from the NumPy signal processing library to look for these regions in our signal function. We define a block to be the set of SNPs from the start to the end of one of the regions identified by the peak finder.","title":"Non-Crossovers"},{"location":"peaks/#look-for-valleys-as-well-as-peaks","text":"Some chromosomes will have N2 SNPs before the main crossover point and CB4856 SNPs after that. In this case the signal decreases before the crossover and increases after that point, so the crossover is at a location where there is a \"valley\" and not a peak. The NumPy function returns locations of both peaks and valleys, and our code saves locations from each type of \"blip\".","title":"Look for Valleys as Well as Peaks"},{"location":"peaks/#maximum-block-size","text":"If a chromosome has a single crossover, the peak finding algorithm will think the sequence from the start of the chromosome up to the crossover location is a block, and the sequence from the crossover point to the end of the chromosome is another block. To prevent these two blocks from being included in the output the script has a block size limit, which is the maximum number of SNPs that can be included in a block. There are also \"pathological\" cases where there are small blips inside a longer region that also stands out from the background. In these situations the peak finder reports the coordinates of the longer enclosing block along with the locations of the smaller blocks nested inside. Choosing a smaller block size limit will prevent the enclosing block from being included in the output while still including the smaller blocks.","title":"Maximum Block Size"},{"location":"peaks/#no-crossovers","text":"Some chromosomes in the data set have no crossover points. In these situations the peak finder will not find a peak or a valley and the output file will have no blocks for this chromosome.","title":"No Crossovers"},{"location":"peaks/#shell-command","text":"To run the peak finder with the default options type $ xo peaks That will read the SNP data from TIGER and write blocks to an output file in CSV format. The default input file name is BSP_TIGER.marker_dataframe.pickle.gzip . A different file name can be specified with the --snps option. The default output file name is peaks.csv . A different name can be specified with --output . The default block size limit is 1000 SNPs. A different value can be specified with the --max_snps option.","title":"Shell Command"},{"location":"peaks/#output-file","text":"The data written by this command is saved in a CSV file. Each row in the file is a SNP that occurs in a block identified by the peak finder. The lines are exact copies of the lines from the original input file, including the original SNP ID in the first column. One new column has been appended to each line. This column is a block ID number, which allows the GUI and visualization commands to group SNPs by blocks.","title":"Output File"},{"location":"peaks_module/","text":"peaks.py peak_finder Top level function for the peaks command. Reads the SNP data, groups it by chromosome, and calls extract_blocks for each chromosome. The results are collected in a data frame and written to a CSV file. Parameters: args \u2013 command line arguments from argparse Source code in src/xo/peaks.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def peak_finder ( args ): ''' Top level function for the `peaks` command. Reads the SNP data, groups it by chromosome, and calls `extract_blocks` for each chromosome. The results are collected in a data frame and written to a CSV file. Arguments: args: command line arguments from `argparse` ''' console = Console () with console . status ( f 'Processing SNPs' , spinner = 'aesthetic' ) as status : console . log ( f 'Reading { args . snps } ' ) snps = pd . read_pickle ( args . snps , compression = 'gzip' ) console . log ( f 'read { len ( snps ) } SNPs' ) result = [] for cname , sf in snps . groupby ( 'chrom_id' ): df = extract_blocks ( sf , args . max_snps ) if df is None : console . log ( f '[red] no blocks in { cname } ' ) else : console . log ( f ' { cname } : { len ( sf ) } SNPs { len ( df ) } in blocks' ) result . append ( df ) final = pd . concat ( result ) console . log ( f 'Writing to { args . output } ' ) final . to_csv ( args . output ) console . log ( f 'Wrote { len ( final ) } records' ) extract_blocks Use find_peaks from the SciPy signal processing library to look for sequences of SNPs. Sequences that \"stand out\" are collected into a block, represented by a data frame with a new column appended to hold the block ID. Parameters: chromosome \u2013 a data frame where each row describes a SNP max_block_size \u2013 the maximum number of SNPs to include in a block Returns: \u2013 a data frame containing all the SNPs in blocks. Source code in src/xo/peaks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def extract_blocks ( chromosome , max_block_size ): ''' Use `find_peaks` from the SciPy signal processing library to look for sequences of SNPs. Sequences that \"stand out\" are collected into a block, represented by a data frame with a new column appended to hold the block ID. Arguments: chromosome: a data frame where each row describes a SNP max_block_size: the maximum number of SNPs to include in a block Returns: a data frame containing all the SNPs in blocks. ''' signal = (( chromosome . hmm_state1 == 'CB4856' ) . cumsum () - ( chromosome . hmm_state1 == 'N2' ) . cumsum ()) . to_numpy () px , prop = find_peaks ( signal , prominence = 1 ) blocks = [] for i in range ( len ( px )): if prop [ 'left_bases' ][ i ] == px [ i ] - prop [ 'prominences' ][ i ]: blk_start = prop [ 'left_bases' ][ i ] + 1 blk_end = px [ i ] else : blk_start = px [ i ] + 1 blk_end = prop [ 'right_bases' ][ i ] if blk_end - blk_start > max_block_size : continue df = chromosome . iloc [ blk_start : blk_end + 1 ] blocks . append ( df . assign ( blk_id = i )) return pd . concat ( blocks ) if blocks else None","title":"peaks"},{"location":"peaks_module/#peakspy","text":"","title":"peaks.py"},{"location":"peaks_module/#peak_finder","text":"Top level function for the peaks command. Reads the SNP data, groups it by chromosome, and calls extract_blocks for each chromosome. The results are collected in a data frame and written to a CSV file. Parameters: args \u2013 command line arguments from argparse Source code in src/xo/peaks.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def peak_finder ( args ): ''' Top level function for the `peaks` command. Reads the SNP data, groups it by chromosome, and calls `extract_blocks` for each chromosome. The results are collected in a data frame and written to a CSV file. Arguments: args: command line arguments from `argparse` ''' console = Console () with console . status ( f 'Processing SNPs' , spinner = 'aesthetic' ) as status : console . log ( f 'Reading { args . snps } ' ) snps = pd . read_pickle ( args . snps , compression = 'gzip' ) console . log ( f 'read { len ( snps ) } SNPs' ) result = [] for cname , sf in snps . groupby ( 'chrom_id' ): df = extract_blocks ( sf , args . max_snps ) if df is None : console . log ( f '[red] no blocks in { cname } ' ) else : console . log ( f ' { cname } : { len ( sf ) } SNPs { len ( df ) } in blocks' ) result . append ( df ) final = pd . concat ( result ) console . log ( f 'Writing to { args . output } ' ) final . to_csv ( args . output ) console . log ( f 'Wrote { len ( final ) } records' )","title":"peak_finder"},{"location":"peaks_module/#extract_blocks","text":"Use find_peaks from the SciPy signal processing library to look for sequences of SNPs. Sequences that \"stand out\" are collected into a block, represented by a data frame with a new column appended to hold the block ID. Parameters: chromosome \u2013 a data frame where each row describes a SNP max_block_size \u2013 the maximum number of SNPs to include in a block Returns: \u2013 a data frame containing all the SNPs in blocks. Source code in src/xo/peaks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def extract_blocks ( chromosome , max_block_size ): ''' Use `find_peaks` from the SciPy signal processing library to look for sequences of SNPs. Sequences that \"stand out\" are collected into a block, represented by a data frame with a new column appended to hold the block ID. Arguments: chromosome: a data frame where each row describes a SNP max_block_size: the maximum number of SNPs to include in a block Returns: a data frame containing all the SNPs in blocks. ''' signal = (( chromosome . hmm_state1 == 'CB4856' ) . cumsum () - ( chromosome . hmm_state1 == 'N2' ) . cumsum ()) . to_numpy () px , prop = find_peaks ( signal , prominence = 1 ) blocks = [] for i in range ( len ( px )): if prop [ 'left_bases' ][ i ] == px [ i ] - prop [ 'prominences' ][ i ]: blk_start = prop [ 'left_bases' ][ i ] + 1 blk_end = px [ i ] else : blk_start = px [ i ] + 1 blk_end = prop [ 'right_bases' ][ i ] if blk_end - blk_start > max_block_size : continue df = chromosome . iloc [ blk_start : blk_end + 1 ] blocks . append ( df . assign ( blk_id = i )) return pd . concat ( blocks ) if blocks else None","title":"extract_blocks"},{"location":"start_app/","text":"Creating and Starting the App Two functions defined at the end of the gui module are called to initialize and start the GUI. make_app Instantiate the top level widget, load data from the data files. Parameters: args \u2013 command line arguments (including names of data files) Returns: \u2013 a PeakViewerApp object Source code in src/xo/gui.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def make_app ( args ): \"\"\" Instantiate the top level widget, load data from the data files. Arguments: args: command line arguments (including names of data files) Returns: a PeakViewerApp object \"\"\" app = PeakViewerApp ( title = 'NCO Explorer' , sidebar_width = SIDEBAR_WIDTH , ) app . load_data ( args ) return app start_app Main entry point, called from the top level xo script. Initialize the Panel library, instantiate the app, and pass the app to the server. Source code in src/xo/gui.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def start_app ( args ): \"\"\" Main entry point, called from the top level `xo` script. Initialize the Panel library, instantiate the app, and pass the app to the server. \"\"\" pn . extension ( design = 'native' ) pn . config . throttled = True try : app = make_app ( args ) pn . serve ( app , port = args . port , verbose = True , autoreload = True , websocket_origin = '*' , ) except Exception as err : logging . error ( err )","title":"Creating and Starting the GUI"},{"location":"start_app/#creating-and-starting-the-app","text":"Two functions defined at the end of the gui module are called to initialize and start the GUI.","title":"Creating and Starting the App"},{"location":"start_app/#make_app","text":"Instantiate the top level widget, load data from the data files. Parameters: args \u2013 command line arguments (including names of data files) Returns: \u2013 a PeakViewerApp object Source code in src/xo/gui.py 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def make_app ( args ): \"\"\" Instantiate the top level widget, load data from the data files. Arguments: args: command line arguments (including names of data files) Returns: a PeakViewerApp object \"\"\" app = PeakViewerApp ( title = 'NCO Explorer' , sidebar_width = SIDEBAR_WIDTH , ) app . load_data ( args ) return app","title":"make_app"},{"location":"start_app/#start_app","text":"Main entry point, called from the top level xo script. Initialize the Panel library, instantiate the app, and pass the app to the server. Source code in src/xo/gui.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def start_app ( args ): \"\"\" Main entry point, called from the top level `xo` script. Initialize the Panel library, instantiate the app, and pass the app to the server. \"\"\" pn . extension ( design = 'native' ) pn . config . throttled = True try : app = make_app ( args ) pn . serve ( app , port = args . port , verbose = True , autoreload = True , websocket_origin = '*' , ) except Exception as err : logging . error ( err )","title":"start_app"},{"location":"vis/","text":"Generate Plots from the Command Line The xo vis command is an alternate method for generating the histograms that summarize blocks across all the chromosomes. Command Line Options The command that runs the program has options to specify settings for each of the filters. To see the complete list of options use the --help option: $ xo vis --help usage: xo vis [-h] [--peaks F] [--chromosomes P] [--size N N] [--length N N] [--coverage N] [--match] [--save F] P positional arguments: P type of plot to make ['count', 'length', 'location'] options: -h, --help show this help message and exit --peaks F blocks saved by peaks.py --chromosomes P chromosome name pattern --size N N block size range (#SNPs) --length N N block length range (bp) --coverage N minimum coverage --match require genome match --save F write summary dataframe to this file According to this output, each time we run the program we have to specify a value for P , which stands for \"plot type.\" The possible values are count , length , and location , which correspond to the three kinds of histograms. Five of the options correspond to the filter widgets and chromosome name widget displayed in the GUI: Use --chromosomes to specify a chromosome name pattern. If you plan to use this option read the section below on \"name patterns in shell commands.\" Use --size and --length to specify block size and length limits. Note that both of these options require two integer arguments, corresponding to the settings of the double-ended slider in the GUI. The --coverage option takes a single integer argument, which corresponds to the value of the coverage slider in the GUI. Including --match on the command line is the same as clicking the toggle button in the match widget. The remaining two options are for specifying file names. The --peaks option can be used to specify an alternative to the default peaks.csv file with the output from the peaks command. Use --save to have the application write the size and location of each block to a CSV file. Default Filter Settings If a filter option is not specified on the command line the default value will be used. Each default is the same as the values shown in the GUI when it first starts. Option Description Default chromosome regular expression for chromosome names BSP.* size block size (number of SNPs) 0 to 10 length block length (base pairs) 0 1o 10000 coverage minimum SNP coverage 0 match require genome match False (unchecked) The default is BSP.* , meaning \"all chromosomes.\" If these options are not specified the defaults are the same as the initial settings shown in the GUI: 0 to 10 for block size, and 0 to 10,000 for block length. Name Patterns in Shell Commands The argument for the --chromosome option is a regular expression, and these expressions often contain asterisks. For example, the pattern BSP-.*-1 means \"all names that start with BSP- and end with -1 with any characters in between\", in other words, \"chromosome 1 from all worms.\" We need to be careful when we use this pattern in a shell command. When a shell sees an asterisk, it thinks you are typing the name of a file, and it tries to look for all files with names that match the pattern. To prevent this behavior, we have to enclose the pattern in single quotes . This is how we would create a histogram of block sizes using only chromosome 1 from each worm: $ xo vis count --chromosomes 'BSP-.*-1' Note: File name expansion -- called \"globbing\" in the Unix world -- is done by the shell. The shell tries to look for files with matching names before it even starts the xo command. If you leave out the quotes you're likely to see an error message like this: zsh: no matches found: BSP-.*-1 Notice how this error is coming from the shell ( zsh in this case, the default shell on macOS) and not from the xo program, which is never even started. Examples For other examples of chromosome name patterns see the Chromosome Names section of the GUI documentation.","title":"Generate Plots from the Command Line"},{"location":"vis/#generate-plots-from-the-command-line","text":"The xo vis command is an alternate method for generating the histograms that summarize blocks across all the chromosomes.","title":"Generate Plots from the Command Line"},{"location":"vis/#command-line-options","text":"The command that runs the program has options to specify settings for each of the filters. To see the complete list of options use the --help option: $ xo vis --help usage: xo vis [-h] [--peaks F] [--chromosomes P] [--size N N] [--length N N] [--coverage N] [--match] [--save F] P positional arguments: P type of plot to make ['count', 'length', 'location'] options: -h, --help show this help message and exit --peaks F blocks saved by peaks.py --chromosomes P chromosome name pattern --size N N block size range (#SNPs) --length N N block length range (bp) --coverage N minimum coverage --match require genome match --save F write summary dataframe to this file According to this output, each time we run the program we have to specify a value for P , which stands for \"plot type.\" The possible values are count , length , and location , which correspond to the three kinds of histograms. Five of the options correspond to the filter widgets and chromosome name widget displayed in the GUI: Use --chromosomes to specify a chromosome name pattern. If you plan to use this option read the section below on \"name patterns in shell commands.\" Use --size and --length to specify block size and length limits. Note that both of these options require two integer arguments, corresponding to the settings of the double-ended slider in the GUI. The --coverage option takes a single integer argument, which corresponds to the value of the coverage slider in the GUI. Including --match on the command line is the same as clicking the toggle button in the match widget. The remaining two options are for specifying file names. The --peaks option can be used to specify an alternative to the default peaks.csv file with the output from the peaks command. Use --save to have the application write the size and location of each block to a CSV file.","title":"Command Line Options"},{"location":"vis/#default-filter-settings","text":"If a filter option is not specified on the command line the default value will be used. Each default is the same as the values shown in the GUI when it first starts. Option Description Default chromosome regular expression for chromosome names BSP.* size block size (number of SNPs) 0 to 10 length block length (base pairs) 0 1o 10000 coverage minimum SNP coverage 0 match require genome match False (unchecked) The default is BSP.* , meaning \"all chromosomes.\" If these options are not specified the defaults are the same as the initial settings shown in the GUI: 0 to 10 for block size, and 0 to 10,000 for block length.","title":"Default Filter Settings"},{"location":"vis/#name-patterns-in-shell-commands","text":"The argument for the --chromosome option is a regular expression, and these expressions often contain asterisks. For example, the pattern BSP-.*-1 means \"all names that start with BSP- and end with -1 with any characters in between\", in other words, \"chromosome 1 from all worms.\" We need to be careful when we use this pattern in a shell command. When a shell sees an asterisk, it thinks you are typing the name of a file, and it tries to look for all files with names that match the pattern. To prevent this behavior, we have to enclose the pattern in single quotes . This is how we would create a histogram of block sizes using only chromosome 1 from each worm: $ xo vis count --chromosomes 'BSP-.*-1' Note: File name expansion -- called \"globbing\" in the Unix world -- is done by the shell. The shell tries to look for files with matching names before it even starts the xo command. If you leave out the quotes you're likely to see an error message like this: zsh: no matches found: BSP-.*-1 Notice how this error is coming from the shell ( zsh in this case, the default shell on macOS) and not from the xo program, which is never even started.","title":"Name Patterns in Shell Commands"},{"location":"vis/#examples","text":"For other examples of chromosome name patterns see the Chromosome Names section of the GUI documentation.","title":"Examples"},{"location":"vis_module/","text":"vis.py This script provides another way to generate a plot that summarizes blocks of SNPs. The command line arguments are: the type of the histogram to make ( count , length , location ); these correspond to the names on the buttons in the summary tab of the GUI filtering paramters that also correspond to widgets in the GUI; specify two integers for size and length ranges, one integer for coverage set_params ( filter , args ) Scan the command line arguments to find filtering parameters, save values in the filter so they can be applied. Parameters: filter \u2013 the SNPFilter object that will do the filtering args \u2013 command line arguments Source code in src/xo/vis.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_params ( filter , args ): ''' Scan the command line arguments to find filtering parameters, save values in the filter so they can be applied. Arguments: filter: the SNPFilter object that will do the filtering args: command line arguments ''' for arg , attr in filter_params . items (): if val := vars ( args ) . get ( arg ): setattr ( filter , attr , val ) count_histogram ( df , args ) Use matplotlib to create and display at histogram of block sizes. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def count_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block sizes. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_size , bins = 10 , rwidth = 0.8 , align = 'left' , range = ( 1 , 100 ), label = args . chromosomes ) plt . title ( 'Block Size' ) plt . xlabel ( 'Number of SNPs' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show () length_histogram ( df , args ) Use matplotlib to create and display at histogram of block lengths. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def length_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block lengths. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_len , bins = 10 , rwidth = 0.8 , label = args . chromosomes ) plt . title ( 'Block Length' ) plt . xlabel ( 'Length (bp)' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show () location_histogram ( df , args ) Use matplotlib to create and display at histogram of block locations. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def location_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block locations. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_loc , bins = 100 , range = ( 0 , 1 ), label = args . chromosomes ) plt . title ( 'Block Location' ) plt . xlabel ( 'Relative Position in the Chromosome' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show () visualize ( args ) Main function of the vis script. Creates a SNPFilter object, saves filtering parameters found on the command line, loads and filters the SNP data, generates a histogram. Parameters: args \u2013 command line arguments Source code in src/xo/vis.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def visualize ( args ): ''' Main function of the `vis` script. Creates a SNPFilter object, saves filtering parameters found on the command line, loads and filters the SNP data, generates a histogram. Arguments: args: command line arguments ''' matplotlib . rcParams . update ({ 'font.size' : 12 }) dispatch = { 'count' : count_histogram , 'length' : length_histogram , 'location' : location_histogram , } filter = SNPFilter () set_params ( filter , args ) logging . info ( 'loading SNP data' ) filter . load_data ( args . peaks ) logging . info ( 'filtering' ) _ , summary = filter . apply () logging . info ( 'plotting' ) dispatch [ args . command ]( summary , args ) if args . save : logging . info ( f 'writing summary frame to { args . save } ' ) summary . to_csv ( args . save ) logging . info ( 'exit' )","title":"vis"},{"location":"vis_module/#vispy","text":"This script provides another way to generate a plot that summarizes blocks of SNPs. The command line arguments are: the type of the histogram to make ( count , length , location ); these correspond to the names on the buttons in the summary tab of the GUI filtering paramters that also correspond to widgets in the GUI; specify two integers for size and length ranges, one integer for coverage","title":"vis.py"},{"location":"vis_module/#src.xo.vis.set_params","text":"Scan the command line arguments to find filtering parameters, save values in the filter so they can be applied. Parameters: filter \u2013 the SNPFilter object that will do the filtering args \u2013 command line arguments Source code in src/xo/vis.py 32 33 34 35 36 37 38 39 40 41 42 43 def set_params ( filter , args ): ''' Scan the command line arguments to find filtering parameters, save values in the filter so they can be applied. Arguments: filter: the SNPFilter object that will do the filtering args: command line arguments ''' for arg , attr in filter_params . items (): if val := vars ( args ) . get ( arg ): setattr ( filter , attr , val )","title":"set_params"},{"location":"vis_module/#src.xo.vis.count_histogram","text":"Use matplotlib to create and display at histogram of block sizes. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def count_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block sizes. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_size , bins = 10 , rwidth = 0.8 , align = 'left' , range = ( 1 , 100 ), label = args . chromosomes ) plt . title ( 'Block Size' ) plt . xlabel ( 'Number of SNPs' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show ()","title":"count_histogram"},{"location":"vis_module/#src.xo.vis.length_histogram","text":"Use matplotlib to create and display at histogram of block lengths. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def length_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block lengths. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_len , bins = 10 , rwidth = 0.8 , label = args . chromosomes ) plt . title ( 'Block Length' ) plt . xlabel ( 'Length (bp)' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show ()","title":"length_histogram"},{"location":"vis_module/#src.xo.vis.location_histogram","text":"Use matplotlib to create and display at histogram of block locations. Parameters: df \u2013 the summary data frame created by applying filters args \u2013 command line arguments Source code in src/xo/vis.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def location_histogram ( df , args ): ''' Use matplotlib to create and display at histogram of block locations. Arguments: df: the summary data frame created by applying filters args: command line arguments ''' fig , ax = plt . subplots () plt . hist ( df . blk_loc , bins = 100 , range = ( 0 , 1 ), label = args . chromosomes ) plt . title ( 'Block Location' ) plt . xlabel ( 'Relative Position in the Chromosome' ) plt . ylabel ( 'Number of Blocks' ) plt . legend ( handlelength = 0 ) plt . show ()","title":"location_histogram"},{"location":"vis_module/#src.xo.vis.visualize","text":"Main function of the vis script. Creates a SNPFilter object, saves filtering parameters found on the command line, loads and filters the SNP data, generates a histogram. Parameters: args \u2013 command line arguments Source code in src/xo/vis.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def visualize ( args ): ''' Main function of the `vis` script. Creates a SNPFilter object, saves filtering parameters found on the command line, loads and filters the SNP data, generates a histogram. Arguments: args: command line arguments ''' matplotlib . rcParams . update ({ 'font.size' : 12 }) dispatch = { 'count' : count_histogram , 'length' : length_histogram , 'location' : location_histogram , } filter = SNPFilter () set_params ( filter , args ) logging . info ( 'loading SNP data' ) filter . load_data ( args . peaks ) logging . info ( 'filtering' ) _ , summary = filter . apply () logging . info ( 'plotting' ) dispatch [ args . command ]( summary , args ) if args . save : logging . info ( f 'writing summary frame to { args . save } ' ) summary . to_csv ( args . save ) logging . info ( 'exit' )","title":"visualize"},{"location":"widgets/","text":"Widget Classes The GUI displayed in a user's browser shows dozens of graphical elements. These \"widgets\" include sliders to specify block sizes and buttons that select different chromosomes. Our GUI uses a common technique that makes it easier to break up code and work on different widgets separately. We define our own widget classes, using inheritance so our objects are a special case of an existing type of widget. A good example is the block size widget. We want to display a slider with a label above it, and we want the slider to have values that range from 0 to 100. The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines our BlockSizeFilterWidget class: class BlockSizeFilterWidget(pn.widgets.IntRangeSlider): ... IntRangeSlider is an existing class, defined in the Panel library. The statement above means our new BlockSizeFilterWidget objects will be special types of IntRangeSliders. The rest of the class defines how our slider should be initialized and what to do when the slider is moved.","title":"Widget Classes"},{"location":"widgets/#widget-classes","text":"The GUI displayed in a user's browser shows dozens of graphical elements. These \"widgets\" include sliders to specify block sizes and buttons that select different chromosomes. Our GUI uses a common technique that makes it easier to break up code and work on different widgets separately. We define our own widget classes, using inheritance so our objects are a special case of an existing type of widget. A good example is the block size widget. We want to display a slider with a label above it, and we want the slider to have values that range from 0 to 100. The Python syntax for defining a new class that is derived from an existing class uses a class statement. This is the statement that defines our BlockSizeFilterWidget class: class BlockSizeFilterWidget(pn.widgets.IntRangeSlider): ... IntRangeSlider is an existing class, defined in the Panel library. The statement above means our new BlockSizeFilterWidget objects will be special types of IntRangeSliders. The rest of the class defines how our slider should be initialized and what to do when the slider is moved.","title":"Widget Classes"}]}